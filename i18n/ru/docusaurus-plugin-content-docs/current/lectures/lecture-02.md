---
sidebar_position: 2
title: "–õ–µ–∫—Ü–∏—è 2: –°–∏—Å—Ç–µ–º–∞ —Ç–∏–ø–æ–≤, —Ç–∏–ø–∞–∂–∏ –∏ –º–æ–¥—É–ª–∏"
---

# –õ–µ–∫—Ü–∏—è 2: –°–∏—Å—Ç–µ–º–∞ —Ç–∏–ø–æ–≤, —Ç–∏–ø–∞–∂–∏ –∏ –º–æ–¥—É–ª–∏ {#lecture-2-types-traits-modules}

**–ü—Ä–æ–¥–æ–ª–∂–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å:** 90 –º–∏–Ω—É—Ç
**–ë–ª–æ–∫:** I ‚Äî –û—Ç C++ –∫ Rust

---

## –î–µ–ª–∞–µ–º –∫–æ–¥ –≥–∏–±–∫–∏–º –∏ –ø–æ–≤—Ç–æ—Ä–Ω–æ –∏—Å–ø–æ–ª—å–∑—É–µ–º—ã–º {#making-code-flexible}

–í [–õ–µ–∫—Ü–∏–∏ 1](./lecture-01.md) –º—ã –æ—Å–≤–æ–∏–ª–∏ —Å–∏—Å—Ç–µ–º—É –≤–ª–∞–¥–µ–Ω–∏—è Rust ‚Äî –æ—Å–Ω–æ–≤—É, –∫–æ—Ç–æ—Ä–∞—è –¥–µ–ª–∞–µ—Ç Rust –±–µ–∑–æ–ø–∞—Å–Ω—ã–º. –ù–æ –æ–¥–Ω–æ–π –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏ –Ω–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –¥–ª—è —Ä–µ–∞–ª—å–Ω—ã—Ö –Ω–∞—É—á–Ω—ã—Ö –≤—ã—á–∏—Å–ª–µ–Ω–∏–π. –í–∞–º –Ω—É–∂–Ω—ã **–≥–∏–±–∫–æ—Å—Ç—å** –∏ **–ø–æ–≤—Ç–æ—Ä–Ω–æ–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ**.

### –û—Ç –≤–ª–∞–¥–µ–Ω–∏—è –∫ –∞–±—Å—Ç—Ä–∞–∫—Ü–∏–∏ {#from-ownership-to-abstraction}

–í—ã –º–æ–∂–µ—Ç–µ —Å–ø—Ä–æ—Å–∏—Ç—å: _–∑–∞—á–µ–º –∏–∑—É—á–∞—Ç—å —Ç–∏–ø—ã –∏ —Ç–∏–ø–∞–∂–∏ –ø–æ—Å–ª–µ –≤–ª–∞–¥–µ–Ω–∏—è?_ –û—Ç–≤–µ—Ç –∫—Ä–æ–µ—Ç—Å—è –≤ —Ç–æ–º, –∫–∞–∫ —ç—Ç–∏ —Å–∏—Å—Ç–µ–º—ã —Ä–∞–±–æ—Ç–∞—é—Ç –≤–º–µ—Å—Ç–µ:

**–í–ª–∞–¥–µ–Ω–∏–µ** (–õ–µ–∫—Ü–∏—è 1) –æ—Ç–≤–µ—á–∞–µ—Ç –Ω–∞ –≤–æ–ø—Ä–æ—Å ¬´–∫–æ–º—É –ø—Ä–∏–Ω–∞–¥–ª–µ–∂–∞—Ç —ç—Ç–∏ –¥–∞–Ω–Ω—ã–µ?¬ª

- –ü—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–∞–µ—Ç –æ—à–∏–±–∫–∏ –ø–∞–º—è—Ç–∏ –Ω–∞ —ç—Ç–∞–ø–µ –∫–æ–º–ø–∏–ª—è—Ü–∏–∏
- –ì–∞—Ä–∞–Ω—Ç–∏—Ä—É–µ—Ç –µ–¥–∏–Ω—Å—Ç–≤–µ–Ω–Ω–æ–≥–æ –ø–∏—Å–∞—Ç–µ–ª—è –∏–ª–∏ –º–Ω–æ–∂–µ—Å—Ç–≤–æ —á–∏—Ç–∞—Ç–µ–ª–µ–π
- –î–µ–ª–∞–µ—Ç –≤—Ä–µ–º–µ–Ω–∞ –∂–∏–∑–Ω–∏ —è–≤–Ω—ã–º–∏

**–¢–∏–ø—ã –∏ —Ç–∏–ø–∞–∂–∏** (–≠—Ç–∞ –ª–µ–∫—Ü–∏—è) –æ—Ç–≤–µ—á–∞—é—Ç –Ω–∞ –≤–æ–ø—Ä–æ—Å ¬´—á—Ç–æ —ç—Ç–∏ –¥–∞–Ω–Ω—ã–µ –º–æ–≥—É—Ç –¥–µ–ª–∞—Ç—å?¬ª

- –û–ø—Ä–µ–¥–µ–ª—è—é—Ç –∫–æ–Ω—Ç—Ä–∞–∫—Ç—ã –ø–æ–≤–µ–¥–µ–Ω–∏—è –º–µ–∂–¥—É –º–æ–¥—É–ª—è–º–∏
- –û–±–µ—Å–ø–µ—á–∏–≤–∞—é—Ç –∞–±—Å—Ç—Ä–∞–∫—Ü–∏–∏ —Å –Ω—É–ª–µ–≤–æ–π —Å—Ç–æ–∏–º–æ—Å—Ç—å—é —á–µ—Ä–µ–∑ –º–æ–Ω–æ–º–æ—Ä—Ñ–∏–∑–∞—Ü–∏—é
- –ü–æ–∑–≤–æ–ª—è—é—Ç —Å–æ–∑–¥–∞–≤–∞—Ç—å –æ–±–æ–±—â—ë–Ω–Ω—ã–µ –∞–ª–≥–æ—Ä–∏—Ç–º—ã, —Ä–∞–±–æ—Ç–∞—é—â–∏–µ —Å —Ä–∞–∑–Ω—ã–º–∏ —Ç–∏–ø–∞–º–∏

–í–º–µ—Å—Ç–µ –æ–Ω–∏ –æ–±—Ä–∞–∑—É—é—Ç —Å–µ–∫—Ä–µ—Ç–Ω—ã–π –∏–Ω–≥—Ä–µ–¥–∏–µ–Ω—Ç Rust: –≤—ã –ø–æ–ª—É—á–∞–µ—Ç–µ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å C++ –±–µ–∑ –µ–≥–æ —Å–ª–æ–∂–Ω–æ—Å—Ç–∏. –°–∏—Å—Ç–µ–º–∞ –≤–ª–∞–¥–µ–Ω–∏—è —É—Å—Ç—Ä–∞–Ω—è–µ—Ç —Ü–µ–ª—ã–µ –∫–ª–∞—Å—Å—ã –æ—à–∏–±–æ–∫, –∞ —Å–∏—Å—Ç–µ–º–∞ —Ç–∏–ø–æ–≤ –æ–±–µ—Å–ø–µ—á–∏–≤–∞–µ—Ç –≥–∏–±–∫–æ—Å—Ç—å –¥–ª—è –Ω–∞–ø–∏—Å–∞–Ω–∏—è –ø–æ–≤—Ç–æ—Ä–Ω–æ –∏—Å–ø–æ–ª—å–∑—É–µ–º–æ–≥–æ, –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º–æ–≥–æ –Ω–∞—É—á–Ω–æ–≥–æ –∫–æ–¥–∞.

–ü–æ–º–Ω–∏—Ç–µ –≥–æ–ª–æ–≤–Ω—É—é –±–æ–ª—å –æ—Ç –º–µ—Ç–∞–ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏—è —à–∞–±–ª–æ–Ω–æ–≤ C++? –†–µ—à–µ–Ω–∏—è –æ –Ω–∞–∫–ª–∞–¥–Ω—ã—Ö —Ä–∞—Å—Ö–æ–¥–∞—Ö –≤–∏—Ä—Ç—É–∞–ª—å–Ω—ã—Ö —Ñ—É–Ω–∫—Ü–∏–π? –û–±—Ä–∞–±–æ—Ç–∫—É –æ—à–∏–±–æ–∫, –∫–æ—Ç–æ—Ä–∞—è –∫–∞–∑–∞–ª–∞—Å—å –∏–≥—Ä–æ–π –≤ –¥–∞—Ä—Ç—Å? Rust —ç–ª–µ–≥–∞–Ω—Ç–Ω–æ —Ä–µ—à–∞–µ—Ç —ç—Ç–æ —Å –ø–æ–º–æ—â—å—é **—Ç–∏–ø–∞–∂–µ–π** ‚Äî —Ñ–æ—Ä–º—ã –ø–æ–ª–∏–º–æ—Ä—Ñ–∏–∑–º–∞, –∫–æ—Ç–æ—Ä–∞—è –æ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω–æ –∏–º–µ–µ—Ç –Ω—É–ª–µ–≤—É—é —Å—Ç–æ–∏–º–æ—Å—Ç—å –∏ –Ω–µ –¥–æ–ø—É—Å–∫–∞–µ—Ç –Ω–µ–ø—Ä–∞–≤–∏–ª—å–Ω–æ–≥–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è.

–°–µ–≥–æ–¥–Ω—è –≤—ã –æ—Å–≤–æ–∏—Ç–µ:

- –ê–ª–≥–µ–±—Ä–∞–∏—á–µ—Å–∫–∏–µ —Ç–∏–ø—ã –¥–∞–Ω–Ω—ã—Ö, –∫–æ—Ç–æ—Ä—ã–µ –¥–µ–ª–∞—é—Ç `std::variant` –∏–∑ C++ –Ω–µ—É–∫–ª—é–∂–∏–º
- –¢–∏–ø–∞–∂–∏: —Å–µ–∫—Ä–µ—Ç–Ω—ã–π –∏–Ω–≥—Ä–µ–¥–∏–µ–Ω—Ç Rust –¥–ª—è –ø–æ–ª–∏–º–æ—Ä—Ñ–∏–∑–º–∞ –≤—Ä–µ–º–µ–Ω–∏ –∫–æ–º–ø–∏–ª—è—Ü–∏–∏
- –û–±—Ä–∞–±–æ—Ç–∫—É –æ—à–∏–±–æ–∫, –∫–æ—Ç–æ—Ä–∞—è –∑–∞—Å—Ç–∞–≤–ª—è–µ—Ç –≤–∞—Å —Ä–µ—à–∞—Ç—å –ø—Ä–æ–±–ª–µ–º—ã _–¥–æ_ –∏—Ö –≤–æ–∑–Ω–∏–∫–Ω–æ–≤–µ–Ω–∏—è
- –û—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏—é –±–æ–ª—å—à–∏—Ö –Ω–∞—É—á–Ω—ã—Ö –∫–æ–¥–æ–≤—ã—Ö –±–∞–∑ —Å –º–æ–¥—É–ª—è–º–∏ –∏ —Ä–∞–±–æ—á–∏–º–∏ –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–∞–º–∏

–î–∞–≤–∞–π—Ç–µ –Ω–∞—á–Ω—ë–º.

## –ß—Ç–æ –≤—ã —Å–æ–∑–¥–∞–¥–∏—Ç–µ —Å–µ–≥–æ–¥–Ω—è {#what-youll-build-today}

–ö –∫–æ–Ω—Ü—É —ç—Ç–æ–π –ª–µ–∫—Ü–∏–∏ –≤—ã —Å–º–æ–∂–µ—Ç–µ:

- **–ú–æ–¥–µ–ª–∏—Ä–æ–≤–∞—Ç—å —Å–ª–æ–∂–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ** —Å –∞–ª–≥–µ–±—Ä–∞–∏—á–µ—Å–∫–∏–º–∏ —Ç–∏–ø–∞–º–∏ (–Ω–∞–ø—Ä–∏–º–µ—Ä: ¬´—Ñ–∞–π–ª —Å–µ—Ç–∫–∏ —É—Å–ø–µ—à–Ω–æ —Ä–∞–∑–æ–±—Ä–∞–Ω¬ª vs ¬´–Ω–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç¬ª vs ¬´—Å–µ—Ç–µ–≤–∞—è –æ—à–∏–±–∫–∞¬ª)
- **–ü–∏—Å–∞—Ç—å –æ–±–æ–±—â—ë–Ω–Ω—ã–µ —á–∏—Å–ª–µ–Ω–Ω—ã–µ –∞–ª–≥–æ—Ä–∏—Ç–º—ã**, —Ä–∞–±–æ—Ç–∞—é—â–∏–µ –¥–ª—è –ª—é–±–æ–≥–æ —á–∏—Å–ª–æ–≤–æ–≥–æ —Ç–∏–ø–∞ –±–µ–∑ –æ—à–∏–±–æ–∫ —à–∞–±–ª–æ–Ω–æ–≤
- **–ì—Ä–∞–º–æ—Ç–Ω–æ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞—Ç—å –æ—à–∏–±–∫–∏** —Å –Ω—É–ª–µ–≤—ã–º–∏ –Ω–∞–∫–ª–∞–¥–Ω—ã–º–∏ —Ä–∞—Å—Ö–æ–¥–∞–º–∏ –∏ –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ—Å—Ç—å—é, –æ–±–µ—Å–ø–µ—á–∏–≤–∞–µ–º–æ–π –∫–æ–º–ø–∏–ª—è—Ç–æ—Ä–æ–º
- **–°—Ç—Ä—É–∫—Ç—É—Ä–∏—Ä–æ–≤–∞—Ç—å –Ω–∞—É—á–Ω—ã–µ –ø—Ä–æ–µ–∫—Ç—ã** –∫–∞–∫ –ø—Ä–æ—Ñ–µ—Å—Å–∏–æ–Ω–∞–ª: —Ä–∞–∑–º–µ—Ç–∫–∞ —Ä–∞–±–æ—á–µ–≥–æ –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–∞, –ø—Ä–∞–≤–∏–ª–∞ –≤–∏–¥–∏–º–æ—Å—Ç–∏, –æ—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏—è –º–æ–¥—É–ª–µ–π
- **–í—ã–±–∏—Ä–∞—Ç—å –ø—Ä–∞–≤–∏–ª—å–Ω—É—é –∞–±—Å—Ç—Ä–∞–∫—Ü–∏—é**: —Å—Ç–∞—Ç–∏—á–µ—Å–∫–∞—è vs –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–∞—è –¥–∏—Å–ø–µ—Ç—á–µ—Ä–∏–∑–∞—Ü–∏—è, –∫–æ–≥–¥–∞ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å `Option` vs `Result`

---

## 1. –°–∏—Å—Ç–µ–º–∞ —Ç–∏–ø–æ–≤: –∑–∞ –ø—Ä–µ–¥–µ–ª–∞–º–∏ –ø—Ä–æ—Å—Ç—ã—Ö –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏–π {#type-system-beyond-enums}

### –ë–æ–ª–µ–≤–∞—è —Ç–æ—á–∫–∞ C++ {#cpp-pain-point}

–í—ã –Ω–∞–≤–µ—Ä–Ω—è–∫–∞ –ø–∏—Å–∞–ª–∏ —Ç–∞–∫–æ–π –∫–æ–¥ –Ω–∞ C++:

```cpp
enum MeshFormat { STL, OBJ, VTK };

struct MeshData {
    MeshFormat format;
    std::variant<std::vector<Triangle>, std::string> data;  // —Ç—Ä–µ—É–≥–æ–ª—å–Ω–∏–∫–∏ –∏–ª–∏ —Å–æ–æ–±—â–µ–Ω–∏–µ –æ–± –æ—à–∏–±–∫–µ
    int num_vertices;
};
```

–ù–µ–º–Ω–æ–≥–æ –Ω–µ—É–∫–ª—é–∂–µ, –ø—Ä–∞–≤–¥–∞? –ß—Ç–æ –µ—Å–ª–∏ –≤–∞—à–µ–π –æ–±—Ä–∞–±–æ—Ç–∫–µ –æ—à–∏–±–æ–∫ –Ω—É–∂–Ω–æ –±–æ–ª—å—à–µ –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞? –ß—Ç–æ –µ—Å–ª–∏ `data` –º–æ–∂–µ—Ç –±—ã—Ç—å –ª–∏–±–æ —Å–µ—Ç–∫–æ–π, _–ª–∏–±–æ_ –æ—à–∏–±–∫–æ–π? –í—ã –ø–æ–ª—É—á–∞–µ—Ç–µ –≤–ª–æ–∂–µ–Ω–Ω—ã–µ –≤–∞—Ä–∏–∞–Ω—Ç—ã –∏ —Å–ª–æ–∂–Ω—É—é –ª–æ–≥–∏–∫—É –ø–æ—Å–µ—â–µ–Ω–∏—è.

`enum` –≤ Rust –ø—Ä–∏–Ω—Ü–∏–ø–∏–∞–ª—å–Ω–æ –æ—Ç–ª–∏—á–∞–µ—Ç—Å—è ‚Äî —ç—Ç–æ **–∞–ª–≥–µ–±—Ä–∞–∏—á–µ—Å–∫–∏–π —Ç–∏–ø –¥–∞–Ω–Ω—ã—Ö**, –∫–æ—Ç–æ—Ä—ã–π –º–æ–∂–µ—Ç —Å–æ–¥–µ—Ä–∂–∞—Ç—å –¥–∞–Ω–Ω—ã–µ –Ω–∞–ø—Ä—è–º—É—é. –î–∞–≤–∞–π—Ç–µ –ø–æ—Å–º–æ—Ç—Ä–∏–º, –∫–∞–∫ —ç—Ç–æ –≤—Å—ë –º–µ–Ω—è–µ—Ç.

### –ê–ª–≥–µ–±—Ä–∞–∏—á–µ—Å–∫–∏–µ —Ç–∏–ø—ã –¥–∞–Ω–Ω—ã—Ö: enum {#algebraic-data-types}

`enum` –≤ Rust –Ω–∞–º–Ω–æ–≥–æ –º–æ—â–Ω–µ–µ, —á–µ–º `enum` –≤ C++:

```rust
// C++ —Å—Ç–∏–ª—å enum (—Ç–æ–∂–µ —Ä–∞–±–æ—Ç–∞–µ—Ç –≤ Rust)
enum Color {
    Red,
    Green,
    Blue,
}

// Rust: enum —Å –¥–∞–Ω–Ω—ã–º–∏ (–∫–∞–∫ C++ std::variant)
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(u8, u8, u8),
}

fn process_message(msg: Message) {
    match msg {
        Message::Quit => println!("Quit"),
        Message::Move { x, y } => println!("Move to ({}, {})", x, y),
        Message::Write(text) => println!("Text: {}", text),
        Message::ChangeColor(r, g, b) => println!("RGB({}, {}, {})", r, g, b),
    }
}
```

### –°—Ä–∞–≤–Ω–µ–Ω–∏–µ —Å C++ std::variant {#compare-with-cpp-variant}

```cpp
// –ü–æ–¥—Ö–æ–¥ C++ (–º–Ω–æ–≥–æ—Å–ª–æ–≤–Ω—ã–π)
using Message = std::variant<
    std::monostate,  // Quit
    std::pair<int, int>,  // Move
    std::string,  // Write
    std::tuple<uint8_t, uint8_t, uint8_t>  // ChangeColor
>;

void process_message(const Message& msg) {
    std::visit([](auto&& arg) {
        using T = std::decay_t<decltype(arg)>;
        if constexpr (std::is_same_v<T, std::monostate>) {
            // ...
        }
        // –∏ —Ç.–¥.
    }, msg);
}
```

### –°–æ–ø–æ—Å—Ç–∞–≤–ª–µ–Ω–∏–µ —Å –æ–±—Ä–∞–∑—Ü–æ–º {#pattern-matching}

–ë–æ–ª–µ–µ –º–æ—â–Ω–æ–µ, —á–µ–º `switch`:

```rust
fn describe_number(n: i32) -> &'static str {
    match n {
        0 => "–Ω–æ–ª—å",
        1 | 2 | 3 => "–º–∞–ª–µ–Ω—å–∫–æ–µ",
        4..=10 => "—Å—Ä–µ–¥–Ω–µ–µ",
        _ if n < 0 => "–æ—Ç—Ä–∏—Ü–∞—Ç–µ–ª—å–Ω–æ–µ",
        _ => "–±–æ–ª—å—à–æ–µ",
    }
}

// –î–µ—Å—Ç—Ä—É–∫—Ç—É—Ä–∏–∑–∞—Ü–∏—è
struct Point { x: i32, y: i32 }

fn classify_point(p: Point) -> &'static str {
    match p {
        Point { x: 0, y: 0 } => "–Ω–∞—á–∞–ª–æ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç",
        Point { x: 0, .. } => "–Ω–∞ –æ—Å–∏ Y",
        Point { y: 0, .. } => "–Ω–∞ –æ—Å–∏ X",
        Point { x, y } if x == y => "–Ω–∞ –¥–∏–∞–≥–æ–Ω–∞–ª–∏",
        _ => "–≥–¥–µ-—Ç–æ –µ—â—ë",
    }
}
```

### –û–±–æ–±—â–µ–Ω–∏—è vs —à–∞–±–ª–æ–Ω—ã C++ {#generics-vs-cpp-templates}

```rust
// –û–±–æ–±—â–µ–Ω–∏—è Rust
fn max<T: PartialOrd>(a: T, b: T) -> T {
    if a > b { a } else { b }
}

// C++20 concepts (–ø–æ—Ö–æ–∂–∞—è –∏–¥–µ—è)
// template<typename T>
// requires std::totally_ordered<T>
// T max(T a, T b) { return a > b ? a : b; }
```

### –ß—Ç–æ —Ç–∞–∫–æ–µ –º–æ–Ω–æ–º–æ—Ä—Ñ–∏–∑–∞—Ü–∏—è? {#what-is-monomorphization}

–ò –≤ C++, –∏ –≤ Rust –æ–±–æ–±—â—ë–Ω–Ω—ã–π –∫–æ–¥ –Ω–µ –∫–æ–º–ø–∏–ª–∏—Ä—É–µ—Ç—Å—è –æ–¥–∏–Ω —Ä–∞–∑ –∏ –Ω–µ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –æ–±–æ–±—â—ë–Ω–Ω–æ –≤–æ –≤—Ä–µ–º—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è. –í–º–µ—Å—Ç–æ —ç—Ç–æ–≥–æ –∫–æ–º–ø–∏–ª—è—Ç–æ—Ä —Å–æ–∑–¥–∞—ë—Ç **—Å–ø–µ—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –≤–µ—Ä—Å–∏–∏** (–º–æ–Ω–æ–º–æ—Ä—Ñ—ã) –¥–ª—è –∫–∞–∂–¥–æ–≥–æ –∏—Å–ø–æ–ª—å–∑—É–µ–º–æ–≥–æ –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–≥–æ —Ç–∏–ø–∞.

**–ò–Ω—Å—Ç–∞–Ω—Ü–∏–∏—Ä–æ–≤–∞–Ω–∏–µ —à–∞–±–ª–æ–Ω–æ–≤ C++:**

```cpp
// –û–¥–Ω–æ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ —à–∞–±–ª–æ–Ω–∞
template<typename T>
T max(T a, T b) { return a > b ? a : b; }

// –ö–æ–≥–¥–∞ –≤—ã–∑—ã–≤–∞–µ—Ç–µ —Å int, –∫–æ–º–ø–∏–ª—è—Ç–æ—Ä –≥–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç:
int max_int(int a, int b) {
    return a > b ? a : b;  // –°–ø–µ—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–æ –¥–ª—è int
}

// –ö–æ–≥–¥–∞ –≤—ã–∑—ã–≤–∞–µ—Ç–µ —Å double, –∫–æ–º–ø–∏–ª—è—Ç–æ—Ä –≥–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç:
double max_double(double a, double b) {
    return a > b ? a : b;  // –°–ø–µ—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–æ –¥–ª—è double
}

// –†–µ–∑—É–ª—å—Ç–∞—Ç: –¢—Ä–∏ –æ—Ç–¥–µ–ª—å–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏ –≤ –±–∏–Ω–∞—Ä–Ω–∏–∫–µ
```

**–ú–æ–Ω–æ–º–æ—Ä—Ñ–∏–∑–∞—Ü–∏—è Rust:**

```rust
// –û–¥–Ω–æ –æ–±–æ–±—â—ë–Ω–Ω–æ–µ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ
fn max<T: PartialOrd>(a: T, b: T) -> T {
    if a > b { a } else { b }
}

// –ö–æ–≥–¥–∞ –≤—ã–∑—ã–≤–∞–µ—Ç–µ —Å i32, –∫–æ–º–ø–∏–ª—è—Ç–æ—Ä –≥–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç:
fn max_i32(a: i32, b: i32) -> i32 { /* —Å–ø–µ—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–æ */ }

// –ö–æ–≥–¥–∞ –≤—ã–∑—ã–≤–∞–µ—Ç–µ —Å f64, –∫–æ–º–ø–∏–ª—è—Ç–æ—Ä –≥–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç:
fn max_f64(a: f64, b: f64) -> f64 { /* —Å–ø–µ—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–æ */ }

// –†–µ–∑—É–ª—å—Ç–∞—Ç: –¢—Ä–∏ –æ—Ç–¥–µ–ª—å–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏ –≤ –±–∏–Ω–∞—Ä–Ω–∏–∫–µ
```

**–ö–ª—é—á–µ–≤—ã–µ —Ä–∞–∑–ª–∏—á–∏—è:**

| –ê—Å–ø–µ–∫—Ç              | –®–∞–±–ª–æ–Ω—ã C++                           | –û–±–æ–±—â–µ–Ω–∏—è Rust                         |
| ------------------- | ------------------------------------- | -------------------------------------- |
| **–°–æ–æ–±—â–µ–Ω–∏—è –æ–± –æ—à–∏–±–∫–∞—Ö** | –ü—Ä–∏ –∏–Ω—Å—Ç–∞–Ω—Ü–∏–∏—Ä–æ–≤–∞–Ω–∏–∏ (–∫—Ä–∏–ø—Ç–æ–≥—Ä–∞—Ñ–∏—á–µ—Å–∫–∏–µ —Ç—Ä–∞—Å—Å–∏—Ä–æ–≤–∫–∏) | –ü—Ä–∏ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–∏ (—á—ë—Ç–∫–∏–µ –≥—Ä–∞–Ω–∏—Ü—ã —Ç–∏–ø–∞–∂–µ–π) |
| **–ö–æ–º–ø–∏–ª—è—Ü–∏—è**     | –û—à–∏–±–∫–∏ —Ç–æ–ª—å–∫–æ –ø—Ä–∏ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–∏       | –û—à–∏–±–∫–∏ —Å—Ä–∞–∑—É –ø—Ä–∏ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–∏           |
| **–ì–µ–Ω–µ—Ä–∞—Ü–∏—è –∫–æ–¥–∞** | –û–¥–∏–Ω–∞–∫–æ–≤–æ (–º–æ–Ω–æ–º–æ—Ä—Ñ–∏–∑–∞—Ü–∏—è)            | –û–¥–∏–Ω–∞–∫–æ–≤–æ (–º–æ–Ω–æ–º–æ—Ä—Ñ–∏–∑–∞—Ü–∏—è)             |
| **–ü—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å** | –ù—É–ª–µ–≤—ã–µ –Ω–∞–∫–ª–∞–¥–Ω—ã–µ —Ä–∞—Å—Ö–æ–¥—ã          | –ù—É–ª–µ–≤—ã–µ –Ω–∞–∫–ª–∞–¥–Ω—ã–µ —Ä–∞—Å—Ö–æ–¥—ã              |

**SFINAE vs –≥—Ä–∞–Ω–∏—Ü—ã —Ç–∏–ø–∞–∂–µ–π Rust:**

C++ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç **Substitution Failure Is Not An Error** (SFINAE) –¥–ª—è –≤–∫–ª—é—á–µ–Ω–∏—è/–æ—Ç–∫–ª—é—á–µ–Ω–∏—è –ø–µ—Ä–µ–≥—Ä—É–∑–æ–∫ —à–∞–±–ª–æ–Ω–æ–≤:

```cpp
// –ü–æ–¥—Ö–æ–¥ C++ (—Å–ª–æ–∂–Ω–æ–µ –º–µ—Ç–∞–ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏–µ —à–∞–±–ª–æ–Ω–æ–≤)
template<typename T, typename = std::enable_if<
    std::is_arithmetic<T>::value,
    void>::type>
auto mean(const std::vector<T>& v) -> T {
    // –ö–æ–º–ø–∏–ª–∏—Ä—É–µ—Ç—Å—è —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ T ‚Äî –∞—Ä–∏—Ñ–º–µ—Ç–∏—á–µ—Å–∫–∏–π —Ç–∏–ø
}
```

**–≠–∫–≤–∏–≤–∞–ª–µ–Ω—Ç Rust (–Ω–∞–º–Ω–æ–≥–æ –ø–æ–Ω—è—Ç–Ω–µ–µ):**

```rust
// –ü–æ–¥—Ö–æ–¥ Rust (—á–∏—Ç–∞–µ–º—ã–µ –≥—Ä–∞–Ω–∏—Ü—ã —Ç–∏–ø–∞–∂–µ–π)
fn mean<T>(data: &[T]) -> T
where
    T: std::ops::Add<Output = T>  // –ê—Ä–∏—Ñ–º–µ—Ç–∏—á–µ—Å–∫–æ–µ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ
       + std::ops::Div<Output = T>, // –î–µ–ª–∏–º—ã–π
       + Copy,                          // –ú–æ–∂–Ω–æ –∫–æ–ø–∏—Ä–æ–≤–∞—Ç—å –∑–Ω–∞—á–µ–Ω–∏—è
{
    // –ö–æ–º–ø–∏–ª—è—Ç–æ—Ä –ø—Ä–æ–≤–µ—Ä—è–µ—Ç –∏—Ö –Ω–∞ —ç—Ç–∞–ø–µ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è!
}
```

**–ü—Ä–µ–∏–º—É—â–µ—Å—Ç–≤–æ Rust:** –ù–µ –Ω—É–∂–Ω–∞ –≥–∏–º–Ω–∞—Å—Ç–∏–∫–∞ –º–µ—Ç–∞–ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏—è —à–∞–±–ª–æ–Ω–æ–≤.

### –°–æ–æ–±—â–µ–Ω–∏—è –æ–± –æ—à–∏–±–∫–∞—Ö: C++ vs Rust {#error-messages-cpp-vs-rust}

–î–∞–≤–∞–π—Ç–µ –ø–æ—Å–º–æ—Ç—Ä–∏–º –Ω–∞ —Ä–∞–∑–Ω–∏—Ü—É, –∫–æ–≥–¥–∞ –º—ã –ø—ã—Ç–∞–µ–º—Å—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —Ç–∏–ø, –∫–æ—Ç–æ—Ä—ã–π –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç —Ç—Ä–µ–±—É–µ–º—ã–µ –æ–ø–µ—Ä–∞—Ü–∏–∏:

**–û—à–∏–±–∫–∞ —à–∞–±–ª–æ–Ω–∞ C++ (–∫—Ä–∏–ø—Ç–æ–≥—Ä–∞—Ñ–∏—á–µ—Å–∫–∞—è):**

```cpp
template<typename T>
T max(T a, T b) {
    return a > b ? a : b;  // –û—à–∏–±–∫–∞: operator> –Ω–µ –æ–ø—Ä–µ–¥–µ–ª—ë–Ω –¥–ª—è T
}

struct Matrix { /* ... */ };

int main() {
    max(matrix1, matrix2);  // –ù–µ —Å–∫–æ–º–ø–∏–ª–∏—Ä—É–µ—Ç—Å—è
}

// –í–´–í–û–î –û–®–ò–ë–ö–ò (50+ —Å—Ç—Ä–æ–∫ —Ç—Ä–∞—Å—Å–∏—Ä–æ–≤–∫–∏ –∏–Ω—Å—Ç–∞–Ω—Ü–∏–∏—Ä–æ–≤–∞–Ω–∏—è —à–∞–±–ª–æ–Ω–∞):
// error: invalid operands to binary expression ('Matrix' and 'Matrix')
//    return a > b ? a : b;
//               ~ ^ ~
// note: candidate function not viable: no known conversion from 'Matrix' to 'const char *'
// note: candidate template ignored: could not match 'Matrix' against 'T'
// ... [–µ—â—ë 40 —Å—Ç—Ä–æ–∫ –∫—Ä–∏–ø—Ç–æ–≥—Ä–∞—Ñ–∏—á–µ—Å–∫–æ–π —Ç—Ä–∞—Å—Å–∏—Ä–æ–≤–∫–∏ —à–∞–±–ª–æ–Ω–∞] ...
```

**–û—à–∏–±–∫–∞ –æ–±–æ–±—â–µ–Ω–∏—è Rust (–ø–æ–Ω—è—Ç–Ω–∞—è):**

```rust
fn max<T: PartialOrd>(a: T, b: T) -> T {
    if a > b { a } else { b }
}

struct Matrix { /* ... */ }

fn main() {
    max(matrix1, matrix2);
}

// –í–´–í–û–î –û–®–ò–ë–ö–ò (2 —Å—Ç—Ä–æ–∫–∏, –æ—á–µ–Ω—å –ø–æ–Ω—è—Ç–Ω–æ):
// error[E0369]: binary operation `>` cannot be applied to type `Matrix`
//  --> src/main.rs:2:8
//   |
// 2 |     if a > b { a } else { b }
//   |        ^^^^^
//   |
//   = note: the trait `PartialOrd` is not implemented for `Matrix`
//
// help: consider annotating `Matrix` with `#[derive(PartialOrd)]`
//        or manually implementing `PartialOrd for Matrix`
```

**–†–∞–∑–Ω–∏—Ü–∞:**

- C++: –¢—Ä–∞—Å—Å–∏—Ä–æ–≤–∫–∞ –∏–Ω—Å—Ç–∞–Ω—Ü–∏–∏—Ä–æ–≤–∞–Ω–∏—è —à–∞–±–ª–æ–Ω–∞ (50+ —Å—Ç—Ä–æ–∫, —Å–ª–æ–∂–Ω–æ –æ—Ç–ª–∞–¥–∏—Ç—å)
- Rust: –ü–æ–Ω—è—Ç–Ω–∞—è –æ—à–∏–±–∫–∞ –≥—Ä–∞–Ω–∏—Ü—ã —Ç–∏–ø–∞–∂–∞ (2 —Å—Ç—Ä–æ–∫–∏, —É–∫–∞–∑—ã–≤–∞–µ—Ç –Ω–∞ —Ç–æ—á–Ω–æ –æ—Ç—Å—É—Ç—Å—Ç–≤—É—é—â–∏–π —Ç–∏–ø–∞–∂)

**–†–µ–∑—é–º–µ –∫–ª—é—á–µ–≤—ã—Ö —Ä–∞–∑–ª–∏—á–∏–π:**

- Rust –ø—Ä–æ–≤–µ—Ä—è–µ—Ç –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è –æ–±–æ–±—â–µ–Ω–∏–π –≤ –º–µ—Å—Ç–µ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è
- –®–∞–±–ª–æ–Ω—ã C++ –ø—Ä–æ–≤–µ—Ä—è—é—Ç—Å—è –ø—Ä–∏ –∏–Ω—Å—Ç–∞–Ω—Ü–∏–∏—Ä–æ–≤–∞–Ω–∏–∏ (–ª—É—á—à–∏–µ —Å–æ–æ–±—â–µ–Ω–∏—è –æ–± –æ—à–∏–±–∫–∞—Ö –≤ Rust)
- Rust: –º–æ–Ω–æ–º–æ—Ä—Ñ–∏–∑–∞—Ü–∏—è (–∫–∞–∫ C++), –Ω–æ —Ç–∞–∫–∂–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç –æ–±—ä–µ–∫—Ç—ã —Ç–∏–ø–∞–∂–µ–π

### C++20 Concepts vs –≥—Ä–∞–Ω–∏—Ü—ã —Ç–∏–ø–∞–∂–µ–π Rust {#cpp20-concepts-vs-rust-traits}

C++20 –≤–≤—ë–ª **concepts** –¥–ª—è —É–ª—É—á—à–µ–Ω–∏—è —Å–æ–æ–±—â–µ–Ω–∏–π –æ–± –æ—à–∏–±–∫–∞—Ö —à–∞–±–ª–æ–Ω–æ–≤. –≠—Ç–æ –æ—á–µ–Ω—å –ø–æ—Ö–æ–∂–µ –Ω–∞ –≥—Ä–∞–Ω–∏—Ü—ã —Ç–∏–ø–∞–∂–µ–π Rust, –Ω–æ –µ—Å—Ç—å –∫–ª—é—á–µ–≤—ã–µ —Ä–∞–∑–ª–∏—á–∏—è.

**C++20 Concepts:**

```cpp
// –û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –∫–æ–Ω—Ü–µ–ø—Ç–∞
template<typename T>
concept Numeric = std::is_arithmetic_v<T> &&
                    std::is_signed_v<T>;

// –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –∫–æ–Ω—Ü–µ–ø—Ç–∞ –¥–ª—è –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è —à–∞–±–ª–æ–Ω–∞
template<Numeric T>
T square(T value) {
    return value * value;
}

// –ò–ª–∏ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ requires clause
template<typename T>
    requires std::is_arithmetic_v<T>
T cube(T value) {
    return value * value * value;
}
```

**–ì—Ä–∞–Ω–∏—Ü—ã —Ç–∏–ø–∞–∂–µ–π Rust (—ç–∫–≤–∏–≤–∞–ª–µ–Ω—Ç):**

```rust
// –û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ —Ç–∏–ø–∞–∂–∞ –∫–∞–∫ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è
trait Numeric: std::ops::Mul<Output = Self> + std::ops::Add<Output = Self> + Copy {}

// –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ —Ç–∏–ø–∞–∂–∞ –¥–ª—è –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è –æ–±–æ–±—â–µ–Ω–∏—è
fn square<T: Numeric>(value: T) -> T {
    value * value
}

// –ò–ª–∏ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ where clause
fn cube<T>(value: T) -> T
where
    T: std::ops::Mul<Output = T> + Copy,
{
    value * value * value
}
```

**–ö–ª—é—á–µ–≤—ã–µ —Ä–∞–∑–ª–∏—á–∏—è:**

| –ê—Å–ø–µ–∫—Ç               | C++20 Concepts            | –ì—Ä–∞–Ω–∏—Ü—ã —Ç–∏–ø–∞–∂–µ–π Rust          |
| -------------------- | ------------------------- | ----------------------------- |
| **–°–∏–Ω—Ç–∞–∫—Å–∏—Å**        | `concept Name = ...`      | `trait Name { ... }`          |
| **–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ**    | `template<Concept T>`     | `fn f<T: Trait>()`            |
| **–û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ**      | –¢—Ä–µ–±—É–µ—Ç –≤–∞–ª–∏–¥–Ω–æ–µ –≤—ã—Ä–∞–∂–µ–Ω–∏–µ | –¢—Ä–µ–±—É–µ—Ç —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—é —Ç–∏–ø–∞–∂–∞     |
| **–°—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–∞—è –±–∏–±–ª–∏–æ—Ç–µ–∫–∞** | –ö–æ–Ω—Ü–µ–ø—Ç—ã –¥–æ–±–∞–≤–ª—è—é—Ç—Å—è | –¢–∏–ø–∞–∂–∏ —É–∂–µ –∑—Ä–µ–ª—ã–µ             |
| **–°–æ–æ–±—â–µ–Ω–∏—è –æ–± –æ—à–∏–±–∫–∞—Ö** | –õ—É—á—à–µ, —á–µ–º —Ä–∞–Ω—å—à–µ     | –ü–æ-–ø—Ä–µ–∂–Ω–µ–º—É –æ—Ç–ª–∏—á–Ω—ã–µ          |

**–ü—Ä–µ–∏–º—É—â–µ—Å—Ç–≤–∞ Rust:**

1. **–ó—Ä–µ–ª–æ—Å—Ç—å**: –£ Rust –µ—Å—Ç—å –≥—Ä–∞–Ω–∏—Ü—ã —Ç–∏–ø–∞–∂–µ–π —Å –≤–µ—Ä—Å–∏–∏ 1.0 (2015)
2. **–ö–æ–º–ø–æ–Ω—É–µ–º–æ—Å—Ç—å**: –¢–∏–ø–∞–∂–∏ –º–æ–≥—É—Ç —Ç—Ä–µ–±–æ–≤–∞—Ç—å –¥—Ä—É–≥–∏–µ —Ç–∏–ø–∞–∂–∏ (—Å—É–ø–µ—Ä—Ç–∏–ø–∞–∂–∏)
3. **–ù—É–ª–µ–≤–∞—è —Å—Ç–æ–∏–º–æ—Å—Ç—å**: –¢–µ –∂–µ –ø—Ä–µ–∏–º—É—â–µ—Å—Ç–≤–∞ –º–æ–Ω–æ–º–æ—Ä—Ñ–∏–∑–∞—Ü–∏–∏
4. **–ü–æ–Ω—è—Ç–Ω–µ–µ**: –ú–µ—Ç–æ–¥—ã —Ç–∏–ø–∞–∂–µ–π –ª—É—á—à–µ –¥–æ–∫—É–º–µ–Ω—Ç–∏—Ä—É—é—Ç –Ω–∞–º–µ—Ä–µ–Ω–∏–µ, —á–µ–º –∫–æ–Ω—Ü–µ–ø—Ç—ã

**–ü—Ä–∏–º–µ—Ä: –ú–Ω–æ–∂–µ—Å—Ç–≤–µ–Ω–Ω—ã–µ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è**

```cpp
// C++20: –ú–Ω–æ–∂–µ—Å—Ç–≤–µ–Ω–Ω—ã–µ –∫–æ–Ω—Ü–µ–ø—Ç—ã
template<typename T>
concept Computable = std::is_arithmetic_v<T> &&
                     std::is_copy_assignable_v<T>;

template<Computable T>
auto compute(const std::vector<T>& v) -> T {
    // ...
}
```

```rust
// Rust: –ú–Ω–æ–∂–µ—Å—Ç–≤–µ–Ω–Ω—ã–µ –≥—Ä–∞–Ω–∏—Ü—ã —Ç–∏–ø–∞–∂–µ–π
fn compute<T>(data: &[T]) -> T
where
    T: std::ops::Add<Output = T>  // –ê—Ä–∏—Ñ–º–µ—Ç–∏–∫–∞
       + std::ops::Mul<T, Output = T>
       + Copy,                         // –ú–æ–∂–Ω–æ –∫–æ–ø–∏—Ä–æ–≤–∞—Ç—å
       + Default,                      // –ú–æ–∂–Ω–æ —Å–æ–∑–¥–∞—Ç—å –Ω–æ–ª—å
{
    data.iter().copied().sum()
}
```

---

## 2. –¢–∏–ø–∞–∂–∏ ‚Äî –ø–æ–ª–∏–º–æ—Ä—Ñ–∏–∑–º Rust {#traits-rust-polymorphism}

### –û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –∏ —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è —Ç–∏–ø–∞–∂–µ–π {#defining-and-implementing-traits}

```rust
trait Numeric {
    fn zero() -> Self;
    fn one() -> Self;
    fn add(&self, other: &Self) -> Self;
    fn mul(&self, other: &Self) -> Self;
}

impl Numeric for f64 {
    fn zero() -> Self { 0.0 }
    fn one() -> Self { 1.0 }
    fn add(&self, other: &Self) -> Self { self + other }
    fn mul(&self, other: &Self) -> Self { self * other }
}

impl Numeric for i32 {
    fn zero() -> Self { 0 }
    fn one() -> Self { 1 }
    fn add(&self, other: &Self) -> Self { self + other }
    fn mul(&self, other: &Self) -> Self { self * other }
}
```

**–°–≤—è–∑—å —Å –õ–µ–∫—Ü–∏–µ–π 1:** –ü–æ–º–Ω–∏—Ç–µ —Å—Ç—Ä—É–∫—Ç—É—Ä—É `Matrix` –∏–∑ [–õ–µ–∫—Ü–∏–∏ 1](./lecture-01.md)? –ú—ã –ø–æ–∫–∞–∑–∞–ª–∏, —á—Ç–æ –µ–π –Ω—É–∂–Ω–æ 7 –∫–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä–æ–≤, 2 –æ–ø–µ—Ä–∞—Ç–æ—Ä–∞ –ø—Ä–∏—Å–≤–∞–∏–≤–∞–Ω–∏—è –∏ –¥–µ—Å—Ç—Ä—É–∫—Ç–æ—Ä –≤ C++, –Ω–æ –æ–Ω–∞ –±—ã–ª–∞ –ø—Ä–æ—Å—Ç–æ–π –≤ Rust. –¢–∏–ø–∞–∂–∏ ‚Äî –ø—Ä–∏—á–∏–Ω–∞ —ç—Ç–æ–≥–æ. –í–º–µ—Å—Ç–æ –ø—Ä–∞–≤–∏–ª–∞ –ø—è—Ç–∏ C++, –≤ Rust –µ—Å—Ç—å:

- –¢–∏–ø–∞–∂ `Clone` (–∫–∞–∫ –∫–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏—è)
- –¢–∏–ø–∞–∂ `Drop` (–∫–∞–∫ –¥–µ—Å—Ç—Ä—É–∫—Ç–æ—Ä)
- –¢–∏–ø–∞–∂ `Default` (–∫–∞–∫ –∫–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é)
- –û–ø–µ—Ä–∞—Ç–æ—Ä–Ω—ã–µ —Ç–∏–ø–∞–∂–∏ (–∫–∞–∫ `Add`, `Mul` –¥–ª—è –ø–µ—Ä–µ–≥—Ä—É–∑–∫–∏)

–ù–∏–∫–∞–∫–æ–π –∏–µ—Ä–∞—Ä—Ö–∏–∏ –Ω–∞—Å–ª–µ–¥–æ–≤–∞–Ω–∏—è –Ω–µ –Ω—É–∂–Ω–æ ‚Äî –ø—Ä–æ—Å—Ç–æ —Ä–µ–∞–ª–∏–∑—É–π—Ç–µ —Ç–∏–ø–∞–∂–∏, –∫–æ—Ç–æ—Ä—ã–µ –≤–∞–º –Ω—É–∂–Ω—ã!

### –¢–∏–ø–∞–∂–∏ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–æ–π –±–∏–±–ª–∏–æ—Ç–µ–∫–∏ {#standard-library-traits}

```rust
// Clone: —è–≤–Ω–æ–µ –¥—É–±–ª–∏—Ä–æ–≤–∞–Ω–∏–µ
#[derive(Clone)]
struct Vector3 {
    x: f64,
    y: f64,
    z: f64,
}

// Copy: –Ω–µ—è–≤–Ω–æ–µ –ø–æ–±–∏—Ç–æ–≤–æ–µ –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏–µ (–¥–æ–ª–∂–µ–Ω —Ç–∞–∫–∂–µ –±—ã—Ç—å Clone)
#[derive(Copy, Clone)]
struct Point2D {
    x: f64,
    y: f64,
}

// Debug: —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ {:?}
#[derive(Debug)]
struct Matrix {
    data: Vec<f64>,
    rows: usize,
    cols: usize,
}

// Default: T::default()
#[derive(Default)]
struct Config {
    iterations: usize,  // –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é 0
    tolerance: f64,     // –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é 0.0
}

// PartialEq, Eq: —Å—Ä–∞–≤–Ω–µ–Ω–∏–µ –Ω–∞ —Ä–∞–≤–µ–Ω—Å—Ç–≤–æ
#[derive(PartialEq)]
struct Complex {
    re: f64,
    im: f64,
}
```

### –ü–µ—Ä–µ–≥—Ä—É–∑–∫–∞ –æ–ø–µ—Ä–∞—Ç–æ—Ä–æ–≤ —á–µ—Ä–µ–∑ —Ç–∏–ø–∞–∂–∏ {#operator-overloading-via-traits}

```rust
use std::ops::{Add, Mul, Index};

#[derive(Clone, Copy, Debug)]
struct Vec3 {
    x: f64,
    y: f64,
    z: f64,
}

impl Add for Vec3 {
    type Output = Vec3;

    fn add(self, other: Vec3) -> Vec3 {
        Vec3 {
            x: self.x + other.x,
            y: self.y + other.y,
            z: self.z + other.z,
        }
    }
}

impl Mul<f64> for Vec3 {
    type Output = Vec3;

    fn mul(self, scalar: f64) -> Vec3 {
        Vec3 {
            x: self.x * scalar,
            y: self.y * scalar,
            z: self.z * scalar,
        }
    }
}

// –°–∫–∞–ª—è—Ä–Ω–æ–µ –ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ: Vec3 * Vec3
impl Mul for Vec3 {
    type Output = f64;

    fn mul(self, other: Vec3) -> f64 {
        self.x * other.x + self.y * other.y + self.z * other.z
    }
}
```

### –†–∞–∑–Ω—ã–µ —Å–ø–æ—Å–æ–±—ã –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è —Ç–∏–ø–∞–∂–µ–π {#different-ways-to-use-traits}

–í—ã —É–≤–∏–¥–∏—Ç–µ —Ç—Ä–∏ —Ä–∞–∑–Ω—ã—Ö –ø–∞—Ç—Ç–µ—Ä–Ω–∞ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è —Ç–∏–ø–∞–∂–µ–π. –í–æ—Ç –∫–æ–≥–¥–∞ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –∫–∞–∂–¥—ã–π:

#### 1. –û–±–æ–±—â—ë–Ω–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è (`impl<T: Trait>`) {#generic-function}

```rust
fn compute_norm<T: Metric>(data: &[T]) -> f64 {
    data.iter().map(|x| x.distance_to_origin()).sum()
}
```

- **–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–æ–≥–¥–∞**: –¢–∏–ø—ã –∏–∑–≤–µ—Å—Ç–Ω—ã –Ω–∞ —ç—Ç–∞–ø–µ –∫–æ–º–ø–∏–ª—è—Ü–∏–∏, –Ω—É–∂–Ω–∞ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å —Å –Ω—É–ª–µ–≤–æ–π —Å—Ç–æ–∏–º–æ—Å—Ç—å—é
- **–ì–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç—Å—è**: –û—Ç–¥–µ–ª—å–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è –∫–∞–∂–¥–æ–≥–æ —Ç–∏–ø–∞ (–º–æ–Ω–æ–º–æ—Ä—Ñ–∏–∑–∞—Ü–∏—è)

#### 2. Impl Trait –≤ –ø–æ–∑–∏—Ü–∏–∏ –≤–æ–∑–≤—Ä–∞—Ç–∞ (`impl Trait`) {#impl-trait-return}

```rust
fn parse_mesh(filename: &str) -> impl Mesh {
    // –ü–∞—Ä—Å–µ—Ä –≤—ã–±–∏—Ä–∞–µ—Ç –æ–ø—Ç–∏–º–∞–ª—å–Ω–æ–µ –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–∏–µ
    if filename.ends_with(".vtk") {
        VtkMesh { /* ... */ }
    } else {
        ObjMesh { /* ... */ }
    }
}
```

- **–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–æ–≥–¥–∞**: –•–æ—Ç–∏—Ç–µ —Å–∫—Ä—ã—Ç—å –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã–π —Ç–∏–ø –æ—Ç –≤—ã–∑—ã–≤–∞—é—â–µ–≥–æ
- **–ü—Ä–∏–º–µ—á–∞–Ω–∏–µ**: –í—ã–∑—ã–≤–∞—é—â–∏–π –º–æ–∂–µ—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —Ç–æ–ª—å–∫–æ –º–µ—Ç–æ–¥—ã –∏–∑ —Ç–∏–ø–∞–∂–∞ `Mesh`

#### 3. –û–±—ä–µ–∫—Ç —Ç–∏–ø–∞–∂–∞ (`dyn Trait`) {#trait-object}

```rust
fn render_meshes(meshes: &[Box<dyn Mesh>]) {
    for mesh in meshes {
        mesh.render();
    }
}
```

- **–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–æ–≥–¥–∞**: –ù—É–∂–Ω–∞ –≥–µ—Ç–µ—Ä–æ–≥–µ–Ω–Ω–∞—è –∫–æ–ª–ª–µ–∫—Ü–∏—è –∏–ª–∏ –¥–∏—Å–ø–µ—Ç—á–µ—Ä–∏–∑–∞—Ü–∏—è –≤—Ä–µ–º–µ–Ω–∏ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è
- **–°—Ç–æ–∏–º–æ—Å—Ç—å**: –ù–∞–∫–ª–∞–¥–Ω—ã–µ —Ä–∞—Å—Ö–æ–¥—ã –Ω–∞ –≤—ã–∑–æ–≤ –≤–∏—Ä—Ç—É–∞–ª—å–Ω–æ–π —Ñ—É–Ω–∫—Ü–∏–∏

### –ß—Ç–æ —Ç–∞–∫–æ–µ ¬´—Å—Ç–∞—Ç–∏—á–µ—Å–∫–∞—è¬ª vs ¬´–¥–∏–Ω–∞–º–∏—á–µ—Å–∫–∞—è¬ª –¥–∏—Å–ø–µ—Ç—á–µ—Ä–∏–∑–∞—Ü–∏—è? {#static-vs-dynamic-dispatch}

–î–ª—è —Ä–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫–æ–≤ C++ —ç—Ç–∏ —Ç–µ—Ä–º–∏–Ω—ã –º–æ–≥—É—Ç –±—ã—Ç—å –∑–∞–ø—É—Ç–∞–Ω–Ω—ã–º–∏. –í–æ—Ç —á—Ç–æ –æ–Ω–∏ –æ–∑–Ω–∞—á–∞—é—Ç –≤ —ç—Ç–æ–º –∫–æ–Ω—Ç–µ–∫—Å—Ç–µ:

**–°—Ç–∞—Ç–∏—á–µ—Å–∫–∞—è –¥–∏—Å–ø–µ—Ç—á–µ—Ä–∏–∑–∞—Ü–∏—è (–≤—Ä–µ–º—è –∫–æ–º–ø–∏–ª—è—Ü–∏–∏):**

- –ö–æ–º–ø–∏–ª—è—Ç–æ—Ä –∑–Ω–∞–µ—Ç **—Ç–æ—á–Ω—ã–π —Ç–∏–ø** –Ω–∞ —ç—Ç–∞–ø–µ –∫–æ–º–ø–∏–ª—è—Ü–∏–∏
- –ì–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç **—Å–ø–µ—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –∫–æ–¥** –¥–ª—è –∫–∞–∂–¥–æ–≥–æ —Ç–∏–ø–∞
- –ú–æ–∂–µ—Ç **–≤—Å—Ç—Ä–æ–∏—Ç—å** —Ñ—É–Ω–∫—Ü–∏–∏ –ø–æ–ª–Ω–æ—Å—Ç—å—é (–Ω—É–ª–µ–≤—ã–µ –Ω–∞–∫–ª–∞–¥–Ω—ã–µ —Ä–∞—Å—Ö–æ–¥—ã)
- Rust: –û–±–æ–±—â–µ–Ω–∏—è, C++: –®–∞–±–ª–æ–Ω—ã

**–î–∏–Ω–∞–º–∏—á–µ—Å–∫–∞—è –¥–∏—Å–ø–µ—Ç—á–µ—Ä–∏–∑–∞—Ü–∏—è (–≤—Ä–µ–º—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è):**

- –¢–∏–ø –æ–ø—Ä–µ–¥–µ–ª—è–µ—Ç—Å—è –≤–æ **–≤—Ä–µ–º—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è** —á–µ—Ä–µ–∑ **vtable** (—Ç–∞–±–ª–∏—Ü–∞ –≤–∏—Ä—Ç—É–∞–ª—å–Ω—ã—Ö —Ñ—É–Ω–∫—Ü–∏–π)
- –í—ã–∑–æ–≤ —Ñ—É–Ω–∫—Ü–∏–∏ —á–µ—Ä–µ–∑ **—É–∫–∞–∑–∞—Ç–µ–ª—å** (–Ω–∞–∫–ª–∞–¥–Ω—ã–µ —Ä–∞—Å—Ö–æ–¥—ã –Ω–∞ –∫–æ—Å–≤–µ–Ω–Ω–æ—Å—Ç—å)
- –ù–µ–ª—å–∑—è –≤—Å—Ç—Ä–æ–∏—Ç—å (–Ω—É–∂–Ω–æ –≤—ã–∑—ã–≤–∞—Ç—å —á–µ—Ä–µ–∑ vtable)
- Rust: `dyn Trait`, C++: –í–∏—Ä—Ç—É–∞–ª—å–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏

**–°–≤—è–∑—å —Å –≤–ª–∞–¥–µ–Ω–∏–µ–º:** –í—ã –º–æ–∂–µ—Ç–µ —Å–ø—Ä–æ—Å–∏—Ç—å, –ø–æ—á–µ–º—É –æ–±—ä–µ–∫—Ç—ã —Ç–∏–ø–∞–∂–µ–π (`dyn Trait`) –≤—Å–µ–≥–¥–∞ –Ω–∞—Ö–æ–¥—è—Ç—Å—è –∑–∞ —Å—Å—ã–ª–∫–∞–º–∏ (`&dyn Trait`) –∏–ª–∏ —É–º–Ω—ã–º–∏ —É–∫–∞–∑–∞—Ç–µ–ª—è–º–∏ (`Box<dyn Trait>`). –í—Å–ø–æ–º–Ω–∏—Ç–µ –∏–∑ [–õ–µ–∫—Ü–∏–∏ 1](./lecture-01.md), —á—Ç–æ Rust –¥–æ–ª–∂–µ–Ω –∑–Ω–∞—Ç—å —Ä–∞–∑–º–µ—Ä –∑–Ω–∞—á–µ–Ω–∏–π –Ω–∞ —ç—Ç–∞–ø–µ –∫–æ–º–ø–∏–ª—è—Ü–∏–∏ –¥–ª—è –≤–ª–∞–¥–µ–Ω–∏—è. –ü–æ—Å–∫–æ–ª—å–∫—É `dyn Trait` –º–æ–∂–µ—Ç –±—ã—Ç—å –ª—é–±—ã–º —Ç–∏–ø–æ–º, —Ä–µ–∞–ª–∏–∑—É—é—â–∏–º —ç—Ç–æ—Ç —Ç–∏–ø–∞–∂, –∫–æ–º–ø–∏–ª—è—Ç–æ—Ä –Ω–µ –º–æ–∂–µ—Ç –∑–Ω–∞—Ç—å –µ–≥–æ —Ä–∞–∑–º–µ—Ä! –ö–æ—Å–≤–µ–Ω–Ω–æ—Å—Ç—å (—Å—Å—ã–ª–∫–∞ –∏–ª–∏ —É–∫–∞–∑–∞—Ç–µ–ª—å) –æ–±–µ—Å–ø–µ—á–∏–≤–∞–µ—Ç —Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω—ã–π —Ä–∞–∑–º–µ—Ä, –ø–æ–∑–≤–æ–ª—è—è —Ñ–∞–∫—Ç–∏—á–µ—Å–∫–∏–º –¥–∞–Ω–Ω—ã–º –≤–∞—Ä—å–∏—Ä–æ–≤–∞—Ç—å—Å—è. –≠—Ç–æ –∏–¥–µ–∞–ª—å–Ω—ã–π –ø—Ä–∏–º–µ—Ä —Å–æ–≤–º–µ—Å—Ç–Ω–æ–π —Ä–∞–±–æ—Ç—ã –≤–ª–∞–¥–µ–Ω–∏—è –∏ —Ç–∏–ø–æ–≤.

**–ê–Ω–∞–ª–æ–≥–∏—è:**

```
–°—Ç–∞—Ç–∏—á–µ—Å–∫–∞—è –¥–∏—Å–ø–µ—Ç—á–µ—Ä–∏–∑–∞—Ü–∏—è:            –î–∏–Ω–∞–º–∏—á–µ—Å–∫–∞—è –¥–∏—Å–ø–µ—Ç—á–µ—Ä–∏–∑–∞—Ü–∏—è:
    –ü—Ä—è–º–æ–π —Ç–µ–ª–µ—Ñ–æ–Ω–Ω—ã–π –∑–≤–æ–Ω–æ–∫            –ü–æ–∏—Å–∫ –≤ —Ç–µ–ª–µ—Ñ–æ–Ω–Ω–æ–π –∫–Ω–∏–≥–µ
    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                       ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    ‚îÇ –ú–∞–º–∞    ‚îÇ  "–ó–≤–æ–Ω–∏ 555-1234"     ‚îÇ –¢–µ–ª–µ—Ñ–æ–Ω–Ω–∞—è‚îÇ
    ‚îî‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                       ‚îÇ –∫–Ω–∏–≥–∞    ‚îÇ
        ‚îÇ                             ‚îî‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
    –ü—Ä—è–º–æ–µ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ                     ‚îÇ
    (–∏–∑–≤–µ—Å—Ç–Ω–æ –Ω–∞ —ç—Ç–∞–ø–µ –∫–æ–º–ø–∏–ª—è—Ü–∏–∏)    –ü–æ–∏—Å–∫ –Ω–æ–º–µ—Ä–∞
                                      (–ø–æ—Ç–æ–º –∑–≤–æ–Ω–æ–∫)
```

**–í–∏–∑—É–∞–ª—å–Ω–æ:**

```
–°—Ç–∞—Ç–∏—á–µ—Å–∫–∞—è –¥–∏—Å–ø–µ—Ç—á–µ—Ä–∏–∑–∞—Ü–∏—è (–º–æ–Ω–æ–º–æ—Ä—Ñ–∏–∑–∞—Ü–∏—è):  –î–∏–Ω–∞–º–∏—á–µ—Å–∫–∞—è –¥–∏—Å–ø–µ—Ç—á–µ—Ä–∏–∑–∞—Ü–∏—è (vtable):
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                 ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  –¢–∏–ø –∏–∑–≤–µ—Å—Ç–µ–Ω –Ω–∞    ‚îÇ                 ‚îÇ  –¢–∏–ø –≤–æ –≤—Ä–µ–º—è      ‚îÇ
‚îÇ  —ç—Ç–∞–ø–µ –∫–æ–º–ø–∏–ª—è—Ü–∏–∏   ‚îÇ                 ‚îÇ  –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è        ‚îÇ
‚îÇ                     ‚îÇ                 ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
‚îÇ  –ì–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç—Å—è:      ‚îÇ                          ‚îÇ
‚îÇ  fn_circle()        ‚îÇ                 ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  fn_rect()          ‚îÇ                 ‚îÇ  –ø–æ–∏—Å–∫ –≤ vtable    ‚îÇ
‚îÇ  fn_triangle()      ‚îÇ                 ‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê‚îÇ
‚îÇ                     ‚îÇ                 ‚îÇ ‚îÇ ptr -> fn()     ‚îÇ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                 ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò‚îÇ
 –ü—Ä—è–º–æ–π –≤—ã–∑–æ–≤                           ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
 (0 –Ω–∞–∫–ª–∞–¥–Ω—ã—Ö —Ä–∞—Å—Ö–æ–¥–æ–≤)                  –ö–æ—Å–≤–µ–Ω–Ω—ã–π –≤—ã–∑–æ–≤
                                         (~2-3x –Ω–∞–∫–ª–∞–¥–Ω—ã–µ —Ä–∞—Å—Ö–æ–¥—ã)
```

**–í–ª–∏—è–Ω–∏–µ –Ω–∞ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å:**

–¢–∞–±–ª–∏—Ü–∞, –∫–æ—Ç–æ—Ä—É—é —è –ø–æ–∫–∞–∑–∞–ª —Ä–∞–Ω–µ–µ, —Ä–∞—Å—Å–∫–∞–∑—ã–≤–∞–µ—Ç –∏—Å—Ç–æ—Ä–∏—é:

```
–°—Ç–∞—Ç–∏—á–µ—Å–∫–∞—è (T: Shape):      2.34–º—Å  (–±–∞–∑–æ–≤–∞—è)
–î–∏–Ω–∞–º–∏—á–µ—Å–∫–∞—è (dyn Shape):    7.43–º—Å  (+217% –Ω–∞–∫–ª–∞–¥–Ω—ã—Ö —Ä–∞—Å—Ö–æ–¥–æ–≤)
```

–î–ª—è –≥–æ—Ä—è—á–∏—Ö –ø—É—Ç–µ–π (—Å–±–æ—Ä–∫–∞ –ú–ö–≠, –º–∞—Ç—Ä–∏—á–Ω—ã–µ –æ–ø–µ—Ä–∞—Ü–∏–∏) –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ —Å—Ç–∞—Ç–∏—á–µ—Å–∫—É—é –¥–∏—Å–ø–µ—Ç—á–µ—Ä–∏–∑–∞—Ü–∏—é. –î–ª—è —Ö–æ–ª–æ–¥–Ω—ã—Ö –ø—É—Ç–µ–π (–∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è, –≤–≤–æ–¥-–≤—ã–≤–æ–¥) –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–∞—è –¥–∏—Å–ø–µ—Ç—á–µ—Ä–∏–∑–∞—Ü–∏—è –¥–æ–ø—É—Å—Ç–∏–º–∞.

**–°—Ä–∞–≤–Ω–µ–Ω–∏–µ —Ä–∞–∑–º–µ—Ç–∫–∏ –ø–∞–º—è—Ç–∏:**

```rust
// –°—Ç–∞—Ç–∏—á–µ—Å–∫–∞—è –¥–∏—Å–ø–µ—Ç—á–µ—Ä–∏–∑–∞—Ü–∏—è (–æ–±–æ–±—â—ë–Ω–Ω–∞—è)
let mesh: Box<impl Mesh> = Box::new(VtkMesh { /* ... */ });
// –†–∞–∑–º–µ—Ä –∏–∑–≤–µ—Å—Ç–µ–Ω –Ω–∞ —ç—Ç–∞–ø–µ –∫–æ–º–ø–∏–ª—è—Ü–∏–∏: —Ç–æ—á–Ω–æ sizeof(VtkMesh)

// –î–∏–Ω–∞–º–∏—á–µ—Å–∫–∞—è –¥–∏—Å–ø–µ—Ç—á–µ—Ä–∏–∑–∞—Ü–∏—è (–æ–±—ä–µ–∫—Ç —Ç–∏–ø–∞–∂–∞)
let mesh: Box<dyn Mesh> = Box::new(VtkMesh { /* ... */ });
// –†–∞–∑–º–µ—Ä: —É–∫–∞–∑–∞—Ç–µ–ª—å –Ω–∞ vtable (8 –±–∞–π—Ç) + –¥–∞–Ω–Ω—ã–µ VtkMesh
```

### –û–±—ä–µ–∫—Ç—ã —Ç–∏–ø–∞–∂–µ–π vs —Å—Ç–∞—Ç–∏—á–µ—Å–∫–∞—è –¥–∏—Å–ø–µ—Ç—á–µ—Ä–∏–∑–∞—Ü–∏—è {#trait-objects-vs-static-dispatch}

```rust
trait Shape {
    fn area(&self) -> f64;
}

struct Circle { radius: f64 }
struct Rectangle { width: f64, height: f64 }

impl Shape for Circle {
    fn area(&self) -> f64 { std::f64::consts::PI * self.radius * self.radius }
}

impl Shape for Rectangle {
    fn area(&self) -> f64 { self.width * self.height }
}

// –°—Ç–∞—Ç–∏—á–µ—Å–∫–∞—è –¥–∏—Å–ø–µ—Ç—á–µ—Ä–∏–∑–∞—Ü–∏—è (–º–æ–Ω–æ–º–æ—Ä—Ñ–∏–∑–∞—Ü–∏—è) ‚Äî –∫–∞–∫ —à–∞–±–ª–æ–Ω—ã C++
fn print_area<T: Shape>(shape: &T) {
    println!("–ü–ª–æ—â–∞–¥—å: {}", shape.area());
}

// –î–∏–Ω–∞–º–∏—á–µ—Å–∫–∞—è –¥–∏—Å–ø–µ—Ç—á–µ—Ä–∏–∑–∞—Ü–∏—è (–æ–±—ä–µ–∫—Ç —Ç–∏–ø–∞–∂–∞) ‚Äî –∫–∞–∫ –≤–∏—Ä—Ç—É–∞–ª—å–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏ C++
fn print_area_dyn(shape: &dyn Shape) {
    println!("–ü–ª–æ—â–∞–¥—å: {}", shape.area());
}

// –•—Ä–∞–Ω–µ–Ω–∏–µ —Å–º–µ—à–∞–Ω–Ω—ã—Ö —Ç–∏–ø–æ–≤
fn total_area(shapes: &[&dyn Shape]) -> f64 {
    shapes.iter().map(|s| s.area()).sum()
}
```

### –°—Ç–∞—Ç–∏—á–µ—Å–∫–∞—è vs –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–∞—è –¥–∏—Å–ø–µ—Ç—á–µ—Ä–∏–∑–∞—Ü–∏—è: –≤–ª–∏—è–Ω–∏–µ –Ω–∞ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å {#static-vs-dynamic-performance}

–î–∞–≤–∞–π—Ç–µ –∏–∑–º–µ—Ä–∏–º —Ä–∞–∑–Ω–∏—Ü—É. –í–æ—Ç –±–µ–Ω—á–º–∞—Ä–∫ –≤—ã—á–∏—Å–ª–µ–Ω–∏—è –ø–ª–æ—â–∞–¥–µ–π 10 000 —Ñ–∏–≥—É—Ä:

| –¢–∏–ø –¥–∏—Å–ø–µ—Ç—á–µ—Ä–∏–∑–∞—Ü–∏–∏    | –†–µ–∞–ª–∏–∑–∞—Ü–∏—è            | –í—Ä–µ–º—è (–Ω—Å) | –ù–∞–∫–ª–∞–¥–Ω—ã–µ —Ä–∞—Å—Ö–æ–¥—ã |
| ---------------------- | --------------------- | ---------- | ----------------- |
| –°—Ç–∞—Ç–∏—á–µ—Å–∫–∞—è (`<T: Shape>`) | –ú–æ–Ω–æ–º–æ—Ä—Ñ–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–∞—è | 2 341 200  | 0% (–±–∞–∑–æ–≤–∞—è)      |
| –î–∏–Ω–∞–º–∏—á–µ—Å–∫–∞—è (`&dyn Shape`) | –ü–æ–∏—Å–∫ –≤ vtable     | 7 428 900  | +217%             |
| C++ Virtual            | –í—ã–∑–æ–≤ –≤–∏—Ä—Ç—É–∞–ª—å–Ω–æ–π —Ñ—É–Ω–∫—Ü–∏–∏ | 7 156 300 | +206%           |

**–ß—Ç–æ –ø—Ä–æ–∏—Å—Ö–æ–¥–∏—Ç?**

```
–°—Ç–∞—Ç–∏—á–µ—Å–∫–∞—è –¥–∏—Å–ø–µ—Ç—á–µ—Ä–∏–∑–∞—Ü–∏—è (–≤—Ä–µ–º—è –∫–æ–º–ø–∏–ª—è—Ü–∏–∏):
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  –ö–æ–º–ø–∏–ª—è—Ç–æ—Ä –≥–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç —Å–ø–µ—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–π‚îÇ
‚îÇ  –∫–æ–¥ –¥–ª—è –∫–∞–∂–¥–æ–≥–æ –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–≥–æ —Ç–∏–ø–∞:      ‚îÇ
‚îÇ    ‚Ä¢ print_area_circle() ‚Üí –≤—Å—Ç—Ä–æ–µ–Ω–æ     ‚îÇ
‚îÇ    ‚Ä¢ print_area_rect() ‚Üí –≤—Å—Ç—Ä–æ–µ–Ω–æ       ‚îÇ
‚îÇ  –†–µ–∑—É–ª—å—Ç–∞—Ç: –ù—É–ª–µ–≤—ã–µ –Ω–∞–∫–ª–∞–¥–Ω—ã–µ —Ä–∞—Å—Ö–æ–¥—ã   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

–î–∏–Ω–∞–º–∏—á–µ—Å–∫–∞—è –¥–∏—Å–ø–µ—Ç—á–µ—Ä–∏–∑–∞—Ü–∏—è (–≤—Ä–µ–º—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è):
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  –û–¥–Ω–∞ —Ñ—É–Ω–∫—Ü–∏—è —Å –ø–æ–∏—Å–∫–æ–º –≤ vtable:       ‚îÇ
‚îÇ    1. –ó–∞–≥—Ä—É–∑–∏—Ç—å —É–∫–∞–∑–∞—Ç–µ–ª—å –Ω–∞ shape      ‚îÇ
‚îÇ    2. –ü—Ä–æ—á–∏—Ç–∞—Ç—å —É–∫–∞–∑–∞—Ç–µ–ª—å —Ñ—É–Ω–∫—Ü–∏–∏ –∏–∑ vtable‚îÇ
‚îÇ    3. –í—ã–∑–≤–∞—Ç—å —á–µ—Ä–µ–∑ —É–∫–∞–∑–∞—Ç–µ–ª—å           ‚îÇ
‚îÇ    4. –ü–æ–≤—Ç–æ—Ä–∏—Ç—å –¥–ª—è –∫–∞–∂–¥–æ–π —Ñ–∏–≥—É—Ä—ã       ‚îÇ
‚îÇ  –†–µ–∑—É–ª—å—Ç–∞—Ç: ~2-3x –Ω–∞–∫–ª–∞–¥–Ω—ã–µ —Ä–∞—Å—Ö–æ–¥—ã     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

**–ö–æ–≥–¥–∞ —á—Ç–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å?**

üí° **–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ —Å—Ç–∞—Ç–∏—á–µ—Å–∫—É—é –¥–∏—Å–ø–µ—Ç—á–µ—Ä–∏–∑–∞—Ü–∏—é (`<T: Shape>`) –∫–æ–≥–¥–∞:**

- –í—ã –∑–Ω–∞–µ—Ç–µ –≤—Å–µ —Ç–∏–ø—ã –Ω–∞ —ç—Ç–∞–ø–µ –∫–æ–º–ø–∏–ª—è—Ü–∏–∏ (—á–∞—Å—Ç–æ –≤ –Ω–∞—É—á–Ω–æ–º –∫–æ–¥–µ)
- –ö—Ä–∏—Ç–∏—á–Ω–∞ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å (—Å–±–æ—Ä–∫–∞ –ú–ö–≠, –º–∞—Ç—Ä–∏—á–Ω—ã–µ –æ–ø–µ—Ä–∞—Ü–∏–∏)
- –ù–∞–±–æ—Ä —Ç–∏–ø–æ–≤ –º–∞–ª –∏ —Å—Ç–∞–±–∏–ª–µ–Ω

üí° **–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –¥–∏–Ω–∞–º–∏—á–µ—Å–∫—É—é –¥–∏—Å–ø–µ—Ç—á–µ—Ä–∏–∑–∞—Ü–∏—é (`&dyn Shape`) –∫–æ–≥–¥–∞:**

- –ù—É–∂–Ω—ã –≥–µ—Ç–µ—Ä–æ–≥–µ–Ω–Ω—ã–µ –∫–æ–ª–ª–µ–∫—Ü–∏–∏ –≤–æ –≤—Ä–µ–º—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è
- –¢–∏–ø—ã –∑–∞–≥—Ä—É–∂–∞—é—Ç—Å—è –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–∏ (–ø–ª–∞–≥–∏–Ω—ã, –æ–ø—Ä–µ–¥–µ–ª—ë–Ω–Ω—ã–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º)
- –ü—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å –Ω–µ —è–≤–ª—è–µ—Ç—Å—è —É–∑–∫–∏–º –º–µ—Å—Ç–æ–º (–∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è, –≤–≤–æ–¥-–≤—ã–≤–æ–¥)

üéØ **–ü–∞—Ç—Ç–µ—Ä–Ω –Ω–∞—É—á–Ω—ã—Ö –≤—ã—á–∏—Å–ª–µ–Ω–∏–π:**

```rust
// –ì–û–†–Ø–ß–ò–ô –ü–£–¢–¨: –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ —Å—Ç–∞—Ç–∏—á–µ—Å–∫—É—é –¥–∏—Å–ø–µ—Ç—á–µ—Ä–∏–∑–∞—Ü–∏—é
fn assemble_stiffness<T: FiniteElement>(elements: &[T]) -> Matrix {
    // –ö–æ–º–ø–∏–ª—è—Ç–æ—Ä —Å–ø–µ—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ—Ç –¥–ª—è –∫–∞–∂–¥–æ–≥–æ —Ç–∏–ø–∞ —ç–ª–µ–º–µ–Ω—Ç–∞
    // –ê–±—Å—Ç—Ä–∞–∫—Ü–∏—è —Å –Ω—É–ª–µ–≤–æ–π —Å—Ç–æ–∏–º–æ—Å—Ç—å—é!
}

// –•–û–õ–û–î–ù–´–ô –ü–£–¢–¨: –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –¥–∏–Ω–∞–º–∏—á–µ—Å–∫—É—é –¥–∏—Å–ø–µ—Ç—á–µ—Ä–∏–∑–∞—Ü–∏—é
fn visualize_mesh(mesh: &dyn MeshRenderer) {
    // –í—ã–∑—ã–≤–∞–µ—Ç—Å—è —Ä–µ–¥–∫–æ, —É–¥–æ–±—Å—Ç–≤–æ –≤–∞–∂–Ω–µ–µ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏
}
```

### –°—É–ø–µ—Ä—Ç–∏–ø–∞–∂–∏: —Ç—Ä–µ–±–æ–≤–∞–Ω–∏—è —Ç–∏–ø–∞–∂–µ–π –¥–ª—è —Ç–∏–ø–∞–∂–µ–π {#supertraits}

–ò–Ω–æ–≥–¥–∞ —Ç–∏–ø–∞–∂ —Ç—Ä–µ–±—É–µ—Ç, —á—Ç–æ–±—ã —Å–Ω–∞—á–∞–ª–∞ –±—ã–ª —Ä–µ–∞–ª–∏–∑–æ–≤–∞–Ω –¥—Ä—É–≥–æ–π —Ç–∏–ø–∞–∂. –û–Ω–∏ –Ω–∞–∑—ã–≤–∞—é—Ç—Å—è **—Å—É–ø–µ—Ä—Ç–∏–ø–∞–∂–∞–º–∏**.

**–°–≤—è–∑—å —Å –ø—Ä–æ–±–ª–µ–º–æ–π —Ä–æ–º–±–∞ –∏–∑ –õ–µ–∫—Ü–∏–∏ 1:** –í [–õ–µ–∫—Ü–∏–∏ 1](./lecture-01.md) –º—ã –ø–æ–∫–∞–∑–∞–ª–∏, –∫–∞–∫ –ø—Ä–æ–±–ª–µ–º–∞ —Ä–æ–º–±–æ–≤–∏–¥–Ω–æ–≥–æ –Ω–∞—Å–ª–µ–¥–æ–≤–∞–Ω–∏—è C++ —Ç—Ä–µ–±—É–µ—Ç –≤–∏—Ä—Ç—É–∞–ª—å–Ω–æ–≥–æ –Ω–∞—Å–ª–µ–¥–æ–≤–∞–Ω–∏—è. –°—É–ø–µ—Ä—Ç–∏–ø–∞–∂–∏ Rust —Ä–µ—à–∞—é—Ç —ç—Ç–æ –∏–Ω–∞—á–µ –∏ –±–æ–ª–µ–µ —ç–ª–µ–≥–∞–Ω—Ç–Ω–æ. –í–º–µ—Å—Ç–æ –Ω–∞—Å–ª–µ–¥–æ–≤–∞–Ω–∏—è –≤—ã –∫–æ–º–ø–æ–Ω—É–µ—Ç–µ —Ç–∏–ø–∞–∂–∏: –µ—Å–ª–∏ `trait B: A`, —Ç–æ –ª—é–±–æ–π —Ç–∏–ø, —Ä–µ–∞–ª–∏–∑—É—é—â–∏–π `B`, –¥–æ–ª–∂–µ–Ω —Ç–∞–∫–∂–µ —Ä–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å `A`. –ù–∏–∫–∞–∫–∏—Ö –Ω–∞–∫–ª–∞–¥–Ω—ã—Ö —Ä–∞—Å—Ö–æ–¥–æ–≤ –≤–∏—Ä—Ç—É–∞–ª—å–Ω–æ–≥–æ –Ω–∞—Å–ª–µ–¥–æ–≤–∞–Ω–∏—è, –Ω–∏–∫–∞–∫–æ–π –Ω–µ–æ–¥–Ω–æ–∑–Ω–∞—á–Ω–æ—Å—Ç–∏ ‚Äî –ø—Ä–æ—Å—Ç–æ —á—ë—Ç–∫–∏–µ —Ç—Ä–µ–±–æ–≤–∞–Ω–∏—è —Ç–∏–ø–∞–∂–µ–π!

**–†–µ–∞–ª—å–Ω—ã–π –ø—Ä–∏–º–µ—Ä**: –î–∏—Ñ—Ñ–µ—Ä–µ–Ω—Ü–∏—Ä—É–µ–º—ã–π –æ–ø—Ç–∏–º–∏–∑–∞—Ç–æ—Ä

```rust
// –ë–∞–∑–æ–≤—ã–π —Ç–∏–ø–∞–∂ –¥–ª—è —Ñ—É–Ω–∫—Ü–∏–π, –∫–æ—Ç–æ—Ä—ã–µ –º—ã –º–æ–∂–µ–º –≤—ã—á–∏—Å–ª–∏—Ç—å
trait Function<T> {
    fn evaluate(&self, x: &[T]) -> T;
}

// –¢–∏–ø–∞–∂ Gradient —Ç—Ä–µ–±—É–µ—Ç Function –∫–∞–∫ —Å—É–ø–µ—Ä—Ç–∏–ø–∞–∂
// –≠—Ç–æ –∑–Ω–∞—á–∏—Ç: –≤—ã –º–æ–∂–µ—Ç–µ —Ä–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å Gradient —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ Function —Ç–æ–∂–µ —Ä–µ–∞–ª–∏–∑–æ–≤–∞–Ω
trait Gradient<T>: Function<T> {
    fn gradient(&self, x: &[T]) -> Vec<T>;
}

// Hessian (–≤—Ç–æ—Ä–∞—è –ø—Ä–æ–∏–∑–≤–æ–¥–Ω–∞—è) —Ç—Ä–µ–±—É–µ—Ç Gradient
trait Hessian<T>: Gradient<T> {
    fn hessian(&self, x: &[T]) -> Vec<Vec<T>>;
}

// –¢–µ–ø–µ—Ä—å —Ä–µ–∞–ª–∏–∑—É–µ–º —Ñ—É–Ω–∫—Ü–∏—é –†–æ–∑–µ–Ω–±—Ä–æ–∫–∞
struct Rosenbrock;

impl Function<f64> for Rosenbrock {
    fn evaluate(&self, x: &[f64]) -> f64 {
        let a = 1.0 - x[0];
        let b = x[1] - x[0] * x[0];
        a * a + 100.0 * b * b
    }
}
```

### –ú–∞—Ç–µ–º–∞—Ç–∏—á–µ—Å–∫–∏–π –≤—ã–≤–æ–¥: –ì—Ä–∞–¥–∏–µ–Ω—Ç –†–æ–∑–µ–Ω–±—Ä–æ–∫–∞

–§—É–Ω–∫—Ü–∏—è –†–æ–∑–µ–Ω–±—Ä–æ–∫–∞:

```

f(x, y) = (1-x)^2 + 100(y-x^2)^2

```

–í—ã—á–∏—Å–ª–∏–º —á–∞—Å—Ç–Ω—ã–µ –ø—Ä–æ–∏–∑–≤–æ–¥–Ω—ã–µ –ø–æ –ø—Ä–∞–≤–∏–ª—É —Ü–µ–ø–æ—á–∫–∏:

**df/dx (–ø–µ—Ä–≤—ã–π —á–ª–µ–Ω):**
```

d/dx [(1-x)^2] = -2(1-x)

```

**df/dx (–≤—Ç–æ—Ä–æ–π —á–ª–µ–Ω):**
```

d/dx [100(y-x^2)^2] = 100 ¬∑ 2(y-x^2) ¬∑ d/dx(y-x^2)
= 200(y-x^2)(-2x)
= -400x(y-x^2)

```

**–û–±—ä–µ–¥–∏–Ω—ë–Ω–Ω—ã–π df/dx:**
```

df/dx = -2(1-x) - 400x(y-x^2)
= -2 + 2x - 400xy + 400x^3

```

**df/dy:**
```

d/dy [(1-x)^2] = 0 (–Ω–µ—Ç —á–ª–µ–Ω–∞ y)
d/dy [100(y-x^2)^2] = 200(y-x^2)

df/dy = 200(y-x^2)

```

–¢–µ–ø–µ—Ä—å –ø—Ä–æ–≤–µ—Ä–∏–º —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—é:

```rust
// –ò–∑ –∫–æ–¥–∞:
df_dx0 = -400.0 * x[0] * (x[1] - x[0] * x[0]) - 2.0 * (1.0 - x[0]);

// –†–∞—Å–∫—Ä–æ–µ–º:
df_dx0 = -400x¬∑(y - x^2) - 2(1 - x)
       = -400xy + 400x^3 - 2 + 2x
       = -2 + 2x - 400xy + 400x^3          ‚úÖ –°–æ–≤–ø–∞–¥–∞–µ—Ç!

df_dx1 = 200.0 * (x[1] - x[0] * x[0]);
       = 200(y - x^2)                      ‚úÖ –°–æ–≤–ø–∞–¥–∞–µ—Ç!
```

```rust
impl Gradient<f64> for Rosenbrock {
    fn gradient(&self, x: &[f64]) -> Vec<f64> {
        let df_dx0 = -400.0 * x[0] * (x[1] - x[0] * x[0]) - 2.0 * (1.0 - x[0]);
        let df_dx1 = 200.0 * (x[1] - x[0] * x[0]);
        vec![df_dx0, df_dx1]
    }
}

// –û–±–æ–±—â—ë–Ω–Ω—ã–π –æ–ø—Ç–∏–º–∏–∑–∞—Ç–æ—Ä —Ä–∞–±–æ—Ç–∞–µ—Ç —Å –ª—é–±–æ–π —Ñ—É–Ω–∫—Ü–∏–µ–π —Å –≥—Ä–∞–¥–∏–µ–Ω—Ç–∞–º–∏
fn newton_optimizer<F>(f: &F, x0: &[f64]) -> Vec<f64>
where
    F: Hessian<f64>,  // –¢—Ä–µ–±—É–µ—Ç: Hessian > Gradient > Function
{
    // –¢–µ–ø–µ—Ä—å –º–æ–∂–µ–º –≤—ã–∑–≤–∞—Ç—å –≤—Å–µ —Ç—Ä–∏ –º–µ—Ç–æ–¥–∞!
    let mut x = x0.to_vec();
    for _ in 0..100 {
        let g = f.gradient(&x);
        let h = f.hessian(&x);
        // –®–∞–≥ –ù—å—é—Ç–æ–Ω–∞: x := x - H^(-1) * g
        x = // ... —Ä–µ—à–∏—Ç—å –ª–∏–Ω–µ–π–Ω—É—é —Å–∏—Å—Ç–µ–º—É ...
    }
    x
}
```

–≠—Ç–æ—Ç –ø–∞—Ç—Ç–µ—Ä–Ω –Ω–µ–≤–µ—Ä–æ—è—Ç–Ω–æ –º–æ—â–Ω—ã–π –≤ –Ω–∞—É—á–Ω—ã—Ö –≤—ã—á–∏—Å–ª–µ–Ω–∏—è—Ö:

- **–ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ–µ —Å–æ–±–ª—é–¥–µ–Ω–∏–µ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–π**: –ö–æ–º–ø–∏–ª—è—Ç–æ—Ä –≥–∞—Ä–∞–Ω—Ç–∏—Ä—É–µ—Ç –ø–æ–ª–Ω—É—é —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—é –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞
- **–ò–µ—Ä–∞—Ä—Ö–∏–∏ —Ç–∏–ø–∞–∂–µ–π**: –°—Ç—Ä–æ–∏—Ç—å –æ—Ç –ø—Ä–æ—Å—Ç–æ–≥–æ –∫ —Å–ª–æ–∂–Ω–æ–º—É
- **–û–±–æ–±—â—ë–Ω–Ω—ã–µ –∞–ª–≥–æ—Ä–∏—Ç–º—ã**: –ü–∏—à–∏—Ç–µ –æ–¥–∏–Ω —Ä–∞–∑, –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ —Å –º–Ω–æ–≥–∏–º–∏ —Ç–∏–ø–∞–º–∏ —Ñ—É–Ω–∫—Ü–∏–π

---

## 2.5 –û–±–æ–±—â–µ–Ω–∏—è –≤ –Ω–∞—É—á–Ω—ã—Ö –≤—ã—á–∏—Å–ª–µ–Ω–∏—è—Ö {#generics-in-scientific-computing}

–û–±–æ–±—â—ë–Ω–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏ –∏ —Ç–∏–ø—ã ‚Äî –æ—Å–Ω–æ–≤–∞ –ø–æ–≤—Ç–æ—Ä–Ω–æ –∏—Å–ø–æ–ª—å–∑—É–µ–º–æ–≥–æ –Ω–∞—É—á–Ω–æ–≥–æ –∫–æ–¥–∞.
–í –æ—Ç–ª–∏—á–∏–µ –æ—Ç —à–∞–±–ª–æ–Ω–æ–≤ C++ (–∫–æ—Ç–æ—Ä—ã–µ –ø–æ —Å—É—Ç–∏ —è–≤–ª—è—é—Ç—Å—è –º–æ–¥–Ω—ã–º–∏ –º–∞–∫—Ä–æ—Å–∞–º–∏),
–æ–±–æ–±—â–µ–Ω–∏—è Rust **–ø—Ä–æ–≤–µ—Ä—è—é—Ç—Å—è –ø–æ —Ç–∏–ø–∞–º –Ω–∞ —ç—Ç–∞–ø–µ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è**, –¥–∞–≤–∞—è –ø–æ–Ω—è—Ç–Ω—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è –æ–± –æ—à–∏–±–∫–∞—Ö, –∫–æ–≥–¥–∞ —á—Ç–æ-—Ç–æ –Ω–µ —Ç–∞–∫.

### –û–±–æ–±—â—ë–Ω–Ω—ã–µ –∞–ª–≥–æ—Ä–∏—Ç–º—ã –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏ {#generic-optimization-algorithms}

–ù–∞–ø–∏—à–µ–º –æ–±–æ–±—â—ë–Ω–Ω—ã–π —Ä–µ—à–∞—Ç–µ–ª—å –ù—å—é—Ç–æ–Ω–∞-–†–∞—Ñ—Å–æ–Ω–∞, –∫–æ—Ç–æ—Ä—ã–π —Ä–∞–±–æ—Ç–∞–µ—Ç –¥–ª—è –ª—é–±–æ–π –¥–∏—Ñ—Ñ–µ—Ä–µ–Ω—Ü–∏—Ä—É–µ–º–æ–π —Ñ—É–Ω–∫—Ü–∏–∏:

```rust
/// –ú–µ—Ç–æ–¥ –ù—å—é—Ç–æ–Ω–∞: x_{n+1} = x_n - f(x_n)/f'(x_n)
pub fn newton_raphson<F>(f: F, x0: f64, tolerance: f64, max_iter: usize) -> Option<f64>
where
    F: Fn(f64) -> (f64, f64),  // –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç (f(x), f'(x))
{
    let mut x = x0;

    for iteration in 0..max_iter {
        let (value, derivative) = f(x);

        if derivative.abs() < 1e-15 {
            eprintln!("–ü—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏–µ: –ù—É–ª–µ–≤–∞—è –ø—Ä–æ–∏–∑–≤–æ–¥–Ω–∞—è –Ω–∞ –∏—Ç–µ—Ä–∞—Ü–∏–∏ {}", iteration);
            return None;
        }

        let delta = value / derivative;
        x -= delta;

        if delta.abs() < tolerance {
            println!("–°—Ö–æ–¥–∏–º–æ—Å—Ç—å –∑–∞ {} –∏—Ç–µ—Ä–∞—Ü–∏–π", iteration + 1);
            return Some(x);
        }
    }

    None
}

/// –û–±–æ–±—â—ë–Ω–Ω–∞—è BFGS –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è (–∫–≤–∞–∑–∏-–Ω—å—é—Ç–æ–Ω–æ–≤—Å–∫–∏–π –º–µ—Ç–æ–¥)
pub struct BFGS<T, F>
where
    T: Copy + std::fmt::Debug,
    F: Fn(&[T]) -> T,
{
    tolerance: T,
    max_iterations: usize,
    objective: F,
}

impl<T, F> BFGS<T, F>
where
    T: Copy + std::fmt::Debug + std::ops::Sub<Output = T> + std::ops::Mul<f64, Output = T>,
    F: Fn(&[T]) -> T,
{
    pub fn new(objective: F, tolerance: T, max_iterations: usize) -> Self {
        Self {
            tolerance,
            max_iterations,
            objective,
        }
    }

    pub fn minimize(&self, x0: &[T]) -> Option<Vec<T>> {
        // –†–µ–∞–ª–∏–∑–∞—Ü–∏—è BFGS...
        // –†–∞–±–æ—Ç–∞–µ—Ç –¥–ª—è f64, f32 –∏–ª–∏ –¥–∞–∂–µ —Å–∏–º–≤–æ–ª—å–Ω—ã—Ö —Ç–∏–ø–æ–≤!
        None
    }
}

// –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: –ù–∞–π—Ç–∏ sqrt –º–µ—Ç–æ–¥–æ–º –ù—å—é—Ç–æ–Ω–∞
fn find_sqrt(n: f64) -> Option<f64> {
    newton_raphson(
        |x| (x * x - n, 2.0 * x),  // f(x) = x^2 - n, f'(x) = 2x
        n.max(1.0),                  // –ù–∞—á–∞–ª—å–Ω–∞—è —Ç–æ—á–∫–∞
        1e-10,                      // –î–æ–ø—É—Å–∫
        100,                        // –ú–∞–∫—Å. –∏—Ç–µ—Ä–∞—Ü–∏–π
    )
}

fn main() {
    let sqrt_2 = find_sqrt(2.0);
    println!("‚àö2 ‚âà {:?}", sqrt_2);  // ‚àö2 ‚âà Some(1.414213562373095)
}
```

### –ö–ª–∞—É–∑—ã `where` –¥–ª—è —Å–ª–æ–∂–Ω—ã—Ö –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–π {#where-clauses}

–ö–æ–≥–¥–∞ –≥—Ä–∞–Ω–∏—Ü—ã —Ç–∏–ø–∞–∂–µ–π —Å—Ç–∞–Ω–æ–≤—è—Ç—Å—è —Å–ª–æ–∂–Ω—ã–º–∏, –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–ª–∞—É–∑—ã `where` –¥–ª—è —á–∏—Ç–∞–µ–º–æ—Å—Ç–∏:

```rust
// –î–æ (—Ç—Ä—É–¥–Ω–æ —á–∏—Ç–∞—Ç—å)
pub fn solve_system<T: std::ops::Add<T, Output = T>
    + std::ops::Mul<T, Output = T>
    + Copy
    + PartialOrd
    + Default>(
    matrix: &[T],
    rhs: &[T]
) -> Vec<T> {
    // ...
}

// –ü–æ—Å–ª–µ (–ø–æ–Ω—è—Ç–Ω–æ!)
pub fn solve_system<T>(matrix: &[T], rhs: &[T]) -> Vec<T>
where
    T: Copy + Default + PartialOrd,
    T: std::ops::Add<T, Output = T>,
    T: std::ops::Mul<T, Output = T>,
{
    // ...
}
```

**–ü–∞—Ç—Ç–µ—Ä–Ω –Ω–∞—É—á–Ω—ã—Ö –≤—ã—á–∏—Å–ª–µ–Ω–∏–π**: –û–±—â–∏–µ –≥—Ä–∞–Ω–∏—Ü—ã —Ç–∏–ø–∞–∂–µ–π

```rust
// –î–ª—è —á–∏—Å–ª–æ–≤—ã—Ö —Ç–∏–ø–æ–≤
where T: Copy + Default + PartialOrd

// –î–ª—è –∞–ª–≥–µ–±—Ä–∞–∏—á–µ—Å–∫–∏—Ö –æ–ø–µ—Ä–∞—Ü–∏–π
where T: std::ops::Add<Output = T>
        + std::ops::Sub<Output = T>
        + std::ops::Mul<Output = T>
        + std::ops::Div<Output = T>

// –î–ª—è —á–∏—Å–µ–ª —Å –ø–ª–∞–≤–∞—é—â–µ–π —Ç–æ—á–∫–æ–π
where T: num_traits::Float + std::fmt::Debug

// –î–ª—è –∑–Ω–∞–∫–æ–≤—ã—Ö —Ü–µ–ª—ã—Ö
where T: num_traits::Signed + std::fmt::Display

// –ö–æ–º–±–∏–Ω–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ
where T: Copy + Default + std::ops::Add<Output = T> + num_traits::Float
```

### –í—ã–≤–æ–¥ —Ç–∏–ø–æ–≤: –ø—É—Å—Ç—å –∫–æ–º–ø–∏–ª—è—Ç–æ—Ä –ø–æ–º–æ–≥–∞–µ—Ç {#type-inference}

–í—ã–≤–æ–¥ —Ç–∏–ø–æ–≤ –≤ Rust –º–æ—â–Ω—ã–π ‚Äî —á–∞—Å—Ç–æ –≤–∞–º –Ω–µ –Ω—É–∂–Ω–æ —É–∫–∞–∑—ã–≤–∞—Ç—å —Ç–∏–ø—ã:

```rust
use num_traits::{Float, One, Zero};

pub fn mean<T>(data: &[T]) -> T
where
    T: Float + Zero + One,
{
    let n = T::from(data.len()).unwrap();  // –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ usize ‚Üí T
    let sum: T = data.iter().cloned().sum();
    sum / n
}

pub fn standard_deviation<T>(data: &[T]) -> T
where
    T: Float + Zero + One,
{
    let mu = mean(data);
    let variance: T = data.iter()
        .map(|&x| (x - mu) * (x - mu))
        .sum::<T>() / T::from(data.len()).unwrap();
    variance.sqrt()
}

// –ö–æ–º–ø–∏–ª—è—Ç–æ—Ä –≤—ã–≤–æ–¥–∏—Ç –≤—Å–µ —Ç–∏–ø—ã
fn analyze() {
    let data_f64 = vec![1.0, 2.0, 3.0, 4.0, 5.0];
    println!("–°—Ä–µ–¥–Ω–µ–µ (f64): {}", mean(&data_f64));
    println!("–°—Ç–∞–Ω–¥. –æ—Ç–∫–ª. (f64): {}", standard_deviation(&data_f64));

    let data_f32: Vec<f32> = data_f64.iter().map(|&x| x as f32).collect();
    println!("–°—Ä–µ–¥–Ω–µ–µ (f32): {}", mean(&data_f32));  // –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç f32!
}
```

### –ê—Å—Å–æ—Ü–∏–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ —Ç–∏–ø—ã: –æ–±–æ–±—â–µ–Ω–∏—è –Ω–∞ —Ç–∏–ø–∞–∂–∞—Ö {#associated-types}

–ò–Ω–æ–≥–¥–∞ —Ç–∏–ø–∞–∂–∞–º –Ω—É–∂–Ω–æ —É–∫–∞–∑—ã–≤–∞—Ç—å –≤–æ–∑–≤—Ä–∞—â–∞–µ–º—ã–µ —Ç–∏–ø—ã, –∫–æ—Ç–æ—Ä—ã–µ –∑–∞–≤–∏—Å—è—Ç –æ—Ç —Ä–µ–∞–ª–∏–∑—É—é—â–µ–≥–æ —Ç–∏–ø–∞:

```rust
pub trait Space<T> {
    /// –¢–∏–ø –≤–µ–∫—Ç–æ—Ä–æ–≤ –≤ —ç—Ç–æ–º –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–µ
    type Vector;

    /// –¢–∏–ø –º–∞—Ç—Ä–∏—Ü (–ª–∏–Ω–µ–π–Ω—ã—Ö –æ–ø–µ—Ä–∞—Ç–æ—Ä–æ–≤) –≤ —ç—Ç–æ–º –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–µ
    type Matrix;

    /// –°–æ–∑–¥–∞—Ç—å –Ω—É–ª–µ–≤–æ–π –≤–µ–∫—Ç–æ—Ä
    fn zero(&self) -> Self::Vector;

    /// –ü—Ä–∏–º–µ–Ω–∏—Ç—å –ª–∏–Ω–µ–π–Ω—ã–π –æ–ø–µ—Ä–∞—Ç–æ—Ä
    fn apply(&self, matrix: &Self::Matrix, vector: &Self::Vector) -> Self::Vector;
}

// –ö–æ–Ω–∫—Ä–µ—Ç–Ω–∞—è —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è –¥–ª—è 2D –µ–≤–∫–ª–∏–¥–æ–≤–∞ –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–∞
pub struct Euclidean2D;

impl Space<f64> for Euclidean2D {
    type Vector = [f64; 2];
    type Matrix = [[f64; 2]; 2];

    fn zero(&self) -> Self::Vector {
        [0.0, 0.0]
    }

    fn apply(&self, matrix: &Self::Matrix, vector: &Self::Vector) -> Self::Vector {
        [
            matrix[0][0] * vector[0] + matrix[0][1] * vector[1],
            matrix[1][0] * vector[0] + matrix[1][1] * vector[1],
        ]
    }
}

// –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: –ù–µ –Ω—É–∂–Ω–æ —É–∫–∞–∑—ã–≤–∞—Ç—å —Ç–∏–ø—ã –≤–µ–∫—Ç–æ—Ä–∞/–º–∞—Ç—Ä–∏—Ü—ã!
let space = Euclidean2D;
let zero = space.zero();
let result = space.apply(&[[1.0, 0.0], [0.0, 1.0]], &zero);
```

**–ê—Å—Å–æ—Ü–∏–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ —Ç–∏–ø—ã vs –æ–±–æ–±—â–µ–Ω–∏—è:**

```rust
// –ê—Å—Å–æ—Ü–∏–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ —Ç–∏–ø—ã: –û–î–ò–ù –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã–π —Ç–∏–ø –Ω–∞ —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—é
trait Normed {
    type Output;  // –ù—É–∂–Ω–æ –≤—ã–±—Ä–∞—Ç—å –æ–¥–∏–Ω –≤—ã—Ö–æ–¥–Ω–æ–π —Ç–∏–ø
    fn norm(&self) -> Self::Output;
}

impl Normed for Vec<f64> {
    type Output = f64;  // –í—Å–µ–≥–¥–∞ f64
    fn norm(&self) -> f64 { /* ... */ }
}

// –û–±–æ–±—â–µ–Ω–∏—è: –ú–æ–∂–Ω–æ –ø–∞—Ä–∞–º–µ—Ç—Ä–∏–∑–æ–≤–∞—Ç—å –Ω–µ—Å–∫–æ–ª—å–∫–æ —Ç–∏–ø–æ–≤
trait Normed<T> {
    fn norm(&self) -> T;  // –í—ã–∑—ã–≤–∞—é—â–∏–π –≤—ã–±–∏—Ä–∞–µ—Ç –≤—ã—Ö–æ–¥–Ω–æ–π —Ç–∏–ø
}

impl Normed<f32> for Vec<f64> {
    fn norm(&self) -> f32 { /* ... */ }  // –ú–æ–∂–µ—Ç –≤–µ—Ä–Ω—É—Ç—å f32
}

impl Normed<f64> for Vec<f64> {
    fn norm(&self) -> f64 { /* ... */ }  // –ú–æ–∂–µ—Ç –≤–µ—Ä–Ω—É—Ç—å f64
}
```

**–ü—Ä–∞–≤–∏–ª–æ –±–æ–ª—å—à–æ–≥–æ –ø–∞–ª—å—Ü–∞**: –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∞—Å—Å–æ—Ü–∏–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ —Ç–∏–ø—ã, –∫–æ–≥–¥–∞ –µ—Å—Ç—å **–æ–¥–∏–Ω –µ—Å—Ç–µ—Å—Ç–≤–µ–Ω–Ω—ã–π –≤—ã–±–æ—Ä**. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –æ–±–æ–±—â–µ–Ω–∏—è, –∫–æ–≥–¥–∞ –≤—ã–∑—ã–≤–∞—é—â–∏–π –¥–æ–ª–∂–µ–Ω **–≤—ã–±–∏—Ä–∞—Ç—å**.

---

## 3. –û–±—Ä–∞–±–æ—Ç–∫–∞ –æ—à–∏–±–æ–∫ {#error-handling}

### `Result<T, E>` –∏ `Option<T>` {#result-and-option}

```rust
// Option: –∑–Ω–∞—á–µ–Ω–∏–µ –º–æ–∂–µ—Ç —Å—É—â–µ—Å—Ç–≤–æ–≤–∞—Ç—å –∏–ª–∏ –Ω–µ—Ç
fn find_element(data: &[i32], target: i32) -> Option<usize> {
    data.iter().position(|&x| x == target)
}

// Result: –æ–ø–µ—Ä–∞—Ü–∏—è –º–æ–∂–µ—Ç –∑–∞–≤–µ—Ä—à–∏—Ç—å—Å—è —Å –æ—à–∏–±–∫–æ–π
fn parse_matrix(input: &str) -> Result<Vec<f64>, ParseError> {
    // ...
}
```

**–°–≤—è–∑—å —Å –≤–ª–∞–¥–µ–Ω–∏–µ–º:** –≠—Ç–∏ —Ç–∏–ø—ã —è–≤–ª—è—é—Ç—Å—è –∞–ª–≥–µ–±—Ä–∞–∏—á–µ—Å–∫–∏–º–∏ —Ç–∏–ø–∞–º–∏ –¥–∞–Ω–Ω—ã—Ö (—Ä–∞—Å—Å–º–æ—Ç—Ä–µ–Ω–Ω—ã–º–∏ —Ä–∞–Ω–µ–µ –≤ —ç—Ç–æ–π –ª–µ–∫—Ü–∏–∏), –∫–æ—Ç–æ—Ä—ã–µ –±–µ—Å—à–æ–≤–Ω–æ —Ä–∞–±–æ—Ç–∞—é—Ç —Å –≤–ª–∞–¥–µ–Ω–∏–µ–º –∏–∑ [–õ–µ–∫—Ü–∏–∏ 1](./lecture-01.md):

- `Option<T>`: –õ–∏–±–æ —Å–æ–¥–µ—Ä–∂–∏—Ç `Some(T)` (–≤–ª–∞–¥–µ–µ–º—ã–π), –ª–∏–±–æ `None` (–¥–∞–Ω–Ω—ã–µ –Ω–µ –Ω—É–∂–Ω—ã)
- `Result<T, E>`: –õ–∏–±–æ —Å–æ–¥–µ—Ä–∂–∏—Ç `Ok(T)` (—É—Å–ø–µ—Ö, –≤–ª–∞–¥–µ–µ–º—ã–µ –¥–∞–Ω–Ω—ã–µ), –ª–∏–±–æ `Err(E)` (–∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ–± –æ—à–∏–±–∫–µ)

–ì–∞—Ä–∞–Ω—Ç–∏–∏ –≤–ª–∞–¥–µ–Ω–∏—è –ø—Ä–∏–º–µ–Ω—è—é—Ç—Å—è: –µ—Å–ª–∏ —É –≤–∞—Å –µ—Å—Ç—å `Some(data)`, –≤—ã –≤–ª–∞–¥–µ–µ—Ç–µ —ç—Ç–∏–º–∏ `data` –∏ –º–æ–∂–µ—Ç–µ –ø–µ—Ä–µ–º–µ—Å—Ç–∏—Ç—å –∏–ª–∏ –∑–∞–∏–º—Å—Ç–≤–æ–≤–∞—Ç—å –∏—Ö. –ï—Å–ª–∏ —É –≤–∞—Å `None`, –Ω–µ—Ç –ø–∞–º—è—Ç–∏ –¥–ª—è –æ—Å–≤–æ–±–æ–∂–¥–µ–Ω–∏—è. –ù–∏–∫–∞–∫–∏—Ö –Ω—É–ª–µ–≤—ã—Ö —É–∫–∞–∑–∞—Ç–µ–ª–µ–π, –Ω–∏–∫–∞–∫–æ–≥–æ use-after-free!

### –û–ø–µ—Ä–∞—Ç–æ—Ä ? {#question-mark-operator}

```rust
use std::fs::File;
use std::io::{self, Read};

// –ë–µ–∑ ?
fn read_file_verbose(path: &str) -> Result<String, io::Error> {
    let file = File::open(path);
    let mut file = match file {
        Ok(f) => f,
        Err(e) => return Err(e),
    };

    let mut contents = String::new();
    match file.read_to_string(&mut contents) {
        Ok(_) => Ok(contents),
        Err(e) => Err(e),
    }
}

// –° ? (—ç–∫–≤–∏–≤–∞–ª–µ–Ω—Ç–Ω–æ, –Ω–æ —á–∏—â–µ)
fn read_file(path: &str) -> Result<String, io::Error> {
    let mut file = File::open(path)?;
    let mut contents = String::new();
    file.read_to_string(&mut contents)?;
    Ok(contents)
}
```

### –ü–æ–¥ –∫–∞–ø–æ—Ç–æ–º: –∫–∞–∫ —Ä–∞–±–æ—Ç–∞–µ—Ç `?` {#how-question-mark-works}

–û–ø–µ—Ä–∞—Ç–æ—Ä `?` ‚Äî —ç—Ç–æ —Å–∏–Ω—Ç–∞–∫—Å–∏—á–µ—Å–∫–∏–π —Å–∞—Ö–∞—Ä, –∫–æ—Ç–æ—Ä—ã–π —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∏—Ä—É–µ—Ç –æ–±—Ä–∞–±–æ—Ç–∫—É –æ—à–∏–±–æ–∫:

```rust
fn read_file(path: &str) -> Result<String, io::Error> {
    let mut file = File::open(path)?;
    let mut contents = String::new();
    file.read_to_string(&mut contents)?;
    Ok(contents)
}
```

–†–∞–∑–≤–æ—Ä–∞—á–∏–≤–∞–µ—Ç—Å—è –≤ —ç—Ç–æ:

```rust
fn read_file_expanded(path: &str) -> Result<String, io::Error> {
    let mut file = match File::open(path) {
        Ok(f) => f,
        Err(e) => return Err(e),  // –†–∞–Ω–Ω–∏–π –≤–æ–∑–≤—Ä–∞—Ç –ø—Ä–∏ –æ—à–∏–±–∫–µ
    };

    let mut contents = String::new();
    match file.read_to_string(&mut contents) {
        Ok(_) => { /* –ø—Ä–æ–¥–æ–ª–∂–∏—Ç—å */ },
        Err(e) => return Err(e),  // –†–∞–Ω–Ω–∏–π –≤–æ–∑–≤—Ä–∞—Ç –ø—Ä–∏ –æ—à–∏–±–∫–µ
    }

    Ok(contents)  // –í–µ—Ä–Ω—É—Ç—å —É—Å–ø–µ—Ö
}
```

**–ü–µ—Ä–µ–¥–∞—á–∞ –≤–ª–∞–¥–µ–Ω–∏—è —Å `?`:** –ó–∞–º–µ—Ç—å—Ç–µ, –∫–∞–∫ –≤–ª–∞–¥–µ–Ω–∏–µ –ø–µ—Ä–µ–¥–∞—ë—Ç—Å—è –≤ —Ä–∞–∑–≤—ë—Ä–Ω—É—Ç–æ–π –≤–µ—Ä—Å–∏–∏. –ö–æ–≥–¥–∞ `File::open(path)?` –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç `Ok(f)`, –≤–ª–∞–¥–µ–Ω–∏–µ `f` –ø–µ—Ä–µ–¥–∞—ë—Ç—Å—è –≤ `file`. –û–ø–µ—Ä–∞—Ç–æ—Ä `?` —Å–æ–±–ª—é–¥–∞–µ—Ç –ø—Ä–∞–≤–∏–ª–∞ –≤–ª–∞–¥–µ–Ω–∏—è –∏–∑ [–õ–µ–∫—Ü–∏–∏ 1](./lecture-01.md) ‚Äî —ç—Ç–æ –Ω–µ –º–∞–≥–∏—è, –∞ –ø—Ä–æ—Å—Ç–æ —Å–∏–Ω—Ç–∞–∫—Å–∏—á–µ—Å–∫–∏–π —Å–∞—Ö–∞—Ä –¥–ª—è —Å–æ–ø–æ—Å—Ç–∞–≤–ª–µ–Ω–∏—è —Å –æ–±—Ä–∞–∑—Ü–æ–º, –∫–æ—Ç–æ—Ä—ã–π –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –≤–ª–∞–¥–µ–µ–º—ã–µ vs –∑–∞–∏–º—Å—Ç–≤–æ–≤–∞–Ω–Ω—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è.

### –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏–µ —Ç–∏–ø—ã –æ—à–∏–±–æ–∫ {#custom-error-types}

```rust
use thiserror::Error;

#[derive(Error, Debug)]
pub enum MatrixError {
    #[error("–Ω–µ—Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏–µ —Ä–∞–∑–º–µ—Ä–Ω–æ—Å—Ç–µ–π: –æ–∂–∏–¥–∞–ª–æ—Å—å {expected}, –ø–æ–ª—É—á–µ–Ω–æ {actual}")]
    DimensionMismatch { expected: usize, actual: usize },

    #[error("–∏–Ω–¥–µ–∫—Å –≤–Ω–µ –≥—Ä–∞–Ω–∏—Ü: ({row}, {col}) –≤ –º–∞—Ç—Ä–∏—Ü–µ {rows}x{cols}")]
    IndexOutOfBounds { row: usize, col: usize, rows: usize, cols: usize },

    #[error("–º–∞—Ç—Ä–∏—Ü–∞ –≤—ã—Ä–æ–∂–¥–µ–Ω–∞")]
    SingularMatrix,

    #[error("–æ—à–∏–±–∫–∞ –≤–≤–æ–¥–∞-–≤—ã–≤–æ–¥–∞: {0}")]
    Io(#[from] std::io::Error),
}

fn solve_linear_system(a: &Matrix, b: &Vector) -> Result<Vector, MatrixError> {
    if a.rows != b.len() {
        return Err(MatrixError::DimensionMismatch {
            expected: a.rows,
            actual: b.len(),
        });
    }
    // ...
}
```

### –¢–∏–ø–∞–∂ `From`: –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ –æ—à–∏–±–æ–∫ {#from-trait}

–ê—Ç—Ä–∏–±—É—Ç `#[from]` –≤ `thiserror` —Ä–µ–∞–ª–∏–∑—É–µ—Ç —Ç–∏–ø–∞–∂ `From`, –∫–æ—Ç–æ—Ä—ã–π `?` –∏—Å–ø–æ–ª—å–∑—É–µ—Ç –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏:

```rust
#[derive(Error, Debug)]
pub enum SimulationError {
    #[error("–æ—à–∏–±–∫–∞ –≤–≤–æ–¥–∞-–≤—ã–≤–æ–¥–∞: {0}")]
    Io(#[from] std::io::Error),

    #[error("–æ—à–∏–±–∫–∞ —Ä–∞–∑–±–æ—Ä–∞: {0}")]
    Parse(#[from] ParseError),

    #[error("–æ—à–∏–±–∫–∞ –º–∞—Ç—Ä–∏—Ü—ã: {0}")]
    Matrix(#[from] MatrixError),
}
```

–≠—Ç–æ –∑–Ω–∞—á–∏—Ç, —á—Ç–æ –≤—ã –º–æ–∂–µ—Ç–µ –ø–∏—Å–∞—Ç—å:

```rust
fn run_simulation(config_file: &str) -> Result<(), SimulationError> {
    // ? –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –ø—Ä–µ–æ–±—Ä–∞–∑—É–µ—Ç std::io::Error ‚Üí SimulationError::Io
    let config = read_config_file(config_file)?;

    // ? –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –ø—Ä–µ–æ–±—Ä–∞–∑—É–µ—Ç ParseError ‚Üí SimulationError::Parse
    let mesh = parse_mesh(&config.mesh_file)?;

    // ? –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –ø—Ä–µ–æ–±—Ä–∞–∑—É–µ—Ç MatrixError ‚Üí SimulationError::Matrix
    let stiffness = assemble_stiffness(&mesh)?;

    Ok(())
}
```

**–¶–µ–ø–æ—á–∫–∞ –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–π:**

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     —Ç–∏–ø–∞–∂ From      ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  io::Error      ‚îÇ ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚Üí ‚îÇ SimulationError::Io  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                      ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                                ‚îÇ
                                                ‚îÇ –æ–ø–µ—Ä–∞—Ç–æ—Ä ?
                                                ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ SimulationError      ‚îÇ ‚Üê –í—Å–µ –æ—à–∏–±–∫–∏ –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω—ã –≤ –æ–¥–∏–Ω —Ç–∏–ø
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

**–†—É—á–Ω–æ–µ –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ (–±–µ–∑ `#[from]`)**:

```rust
// –ú–Ω–æ–≥–æ—Å–ª–æ–≤–Ω–∞—è –≤–µ—Ä—Å–∏—è
let config = read_config_file(config_file)
    .map_err(SimulationError::Io)?;
```

**–° `#[from]`**:

```rust
// –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏!
let config = read_config_file(config_file)?;
```

**–ü–∞—Ç—Ç–µ—Ä–Ω –Ω–∞—É—á–Ω—ã—Ö –≤—ã—á–∏—Å–ª–µ–Ω–∏–π:**

–°–æ–∑–¥–∞–π—Ç–µ **–∏–µ—Ä–∞—Ä—Ö–∏—é** –æ—à–∏–±–æ–∫:

```rust
// –ù–∏–∑–∫–æ—É—Ä–æ–≤–Ω–µ–≤—ã–µ –æ—à–∏–±–∫–∏ (—Å–ø–µ—Ü–∏—Ñ–∏—á–Ω—ã–µ)
pub enum MathError { Singular, NotPositiveDefinite }
pub enum ParseError { InvalidFormat, UnexpectedToken }

// –°—Ä–µ–¥–Ω–µ—É—Ä–æ–≤–Ω–µ–≤—ã–µ –æ—à–∏–±–∫–∏ (–ø—Ä–µ–¥–º–µ—Ç–Ω–æ-—Å–ø–µ—Ü–∏—Ñ–∏—á–Ω—ã–µ)
pub enum FiniteElementError {
    #[from] MathError,
    #[from] ParseError,
    BadElementTopology,
}

// –í—ã—Å–æ–∫–æ—É—Ä–æ–≤–Ω–µ–≤—ã–µ –æ—à–∏–±–∫–∏ (–ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è)
pub enum SimulationError {
    #[from] FiniteElementError,
    #[from] std::io::Error,
    #[from] std::time::SystemTimeError,
    MaxIterationsReached,
}
```

–¢–µ–ø–µ—Ä—å –≤—ã –ø–æ–ª—É—á–∞–µ—Ç–µ **–∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ –æ—à–∏–±–æ–∫** –Ω–∞ –∫–∞–∂–¥–æ–º —É—Ä–æ–≤–Ω–µ!

### –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏–µ —Å–æ–æ–±—â–µ–Ω–∏—è –æ–± –æ—à–∏–±–∫–∞—Ö —Å `Display` {#custom-error-messages}

–ò–Ω–æ–≥–¥–∞ –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–≥–æ –∞—Ç—Ä–∏–±—É—Ç–∞ `#[error]` –Ω–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ. –í—ã –º–æ–∂–µ—Ç–µ –Ω–∞—Å—Ç—Ä–æ–∏—Ç—å –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ:

```rust
use std::fmt;

#[derive(Debug)]
pub enum ConvergenceError {
    MaxIterations { iterations: usize, residual: f64 },
    NanEncountered { iteration: usize, variable: String },
    StepSizeTooSmall { current: f64, min_allowed: f64 },
}

impl fmt::Display for ConvergenceError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            ConvergenceError::MaxIterations { iterations, residual } => {
                write!(f,
                    "–ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ–π—Ç–∏—Å—å –∑–∞ {} –∏—Ç–µ—Ä–∞—Ü–∏–π (–Ω–µ–≤—è–∑–∫–∞: {:.2e})",
                    iterations, residual
                )
            }
            ConvergenceError::NanEncountered { iteration, variable } => {
                write!(f,
                    "NaN –æ–±–Ω–∞—Ä—É–∂–µ–Ω –≤ –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π '{}' –Ω–∞ –∏—Ç–µ—Ä–∞—Ü–∏–∏ {}",
                    variable, iteration
                )
            }
            ConvergenceError::StepSizeTooSmall { current, min_allowed } => {
                write!(f,
                    "–†–∞–∑–º–µ—Ä —à–∞–≥–∞ ({:.2e}) –Ω–∏–∂–µ –º–∏–Ω–∏–º–∞–ª—å–Ω–æ–≥–æ ({:.2e})",
                    current, min_allowed
                )
            }
        }
    }
}

// –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ
fn solve_nonlinear_system() -> Result<Vector, ConvergenceError> {
    // ...
    Err(ConvergenceError::MaxIterations {
        iterations: 1000,
        residual: 1e-6,
    })
}

fn main() {
    match solve_nonlinear_system() {
        Ok(x) => println!("–†–µ—à–µ–Ω–∏–µ: {:?}", x),
        Err(e) => eprintln!("–û—à–∏–±–∫–∞: {}", e),  // –ò—Å–ø–æ–ª—å–∑—É–µ—Ç Display
    }
}

// –í—ã–≤–æ–¥:
// –û—à–∏–±–∫–∞: –ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ–π—Ç–∏—Å—å –∑–∞ 1000 –∏—Ç–µ—Ä–∞—Ü–∏–π (–Ω–µ–≤—è–∑–∫–∞: 1.00e-06)
```

üí° **–°–æ–≤–µ—Ç –ø—Ä–æ—Ñ–µ—Å—Å–∏–æ–Ω–∞–ª–∞:** –ö–æ–º–±–∏–Ω–∏—Ä—É–π—Ç–µ `Debug` (–¥–ª—è –¥–µ—Ç–∞–ª—å–Ω–æ–≥–æ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è) –∏ `Display` (–¥–ª—è —Å–æ–æ–±—â–µ–Ω–∏–π –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é):

```rust
fn main() {
    if let Err(e) = run_simulation() {
        eprintln!("–ü–æ–Ω—è—Ç–Ω–∞—è –æ—à–∏–±–∫–∞: {}", e);      // Display
        if std::env::var("DEBUG").is_ok() {
            eprintln!("–û—Ç–ª–∞–¥–æ—á–Ω–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è: {:#?}", e);        // Debug
        }
    }
}
```

### –ü–æ—á–µ–º—É –Ω–µ –∏—Å–∫–ª—é—á–µ–Ω–∏—è? {#why-no-exceptions}

| –ê—Å–ø–µ–∫—Ç           | –ò—Å–∫–ª—é—á–µ–Ω–∏—è (C++)         | Result (Rust)            |
| ---------------- | ------------------------ | ------------------------ |
| –ü–æ—Ç–æ–∫ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è | –°–∫—Ä—ã—Ç—ã–π, –Ω–µ–ª–æ–∫–∞–ª—å–Ω—ã–π     | –Ø–≤–Ω—ã–π, –ª–æ–∫–∞–ª—å–Ω—ã–π         |
| –ü—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å | –ù–∞–∫–ª–∞–¥–Ω—ã–µ —Ä–∞—Å—Ö–æ–¥—ã –Ω–∞ —Ä–∞—Å–∫—Ä—É—Ç–∫—É —Å—Ç–µ–∫–∞ | –ù—É–ª–µ–≤–∞—è —Å—Ç–æ–∏–º–æ—Å—Ç—å –ø—Ä–∏ –æ—Ç—Å—É—Ç—Å—Ç–≤–∏–∏ –æ—à–∏–±–∫–∏ |
| –ü—Ä–æ–≤–µ—Ä–∫–∞        | –õ–µ–≥–∫–æ –∑–∞–±—ã—Ç—å try/catch    | –ö–æ–º–ø–∏–ª—è—Ç–æ—Ä –∑–∞—Å—Ç–∞–≤–ª—è–µ—Ç –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞—Ç—å |
| –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ–± –æ—à–∏–±–∫–µ | –ü–æ–ª–∏–º–æ—Ä—Ñ–∏–∑–º –≤—Ä–µ–º–µ–Ω–∏ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è | –ò–∑–≤–µ—Å—Ç–Ω–∞ –Ω–∞ —ç—Ç–∞–ø–µ –∫–æ–º–ø–∏–ª—è—Ü–∏–∏ |

---

## 4. –°–∏—Å—Ç–µ–º–∞ –º–æ–¥—É–ª–µ–π {#module-system}

### –ë–∞–∑–æ–≤—ã–µ –º–æ–¥—É–ª–∏ {#basic-modules}

```rust
// –í src/lib.rs –∏–ª–∏ src/main.rs
mod math {
    pub fn add(a: i32, b: i32) -> i32 {
        a + b
    }

    fn helper() {  // –ü—Ä–∏–≤–∞—Ç–Ω—ã–π –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
        // ...
    }

    pub mod linalg {
        pub struct Matrix { /* ... */ }
    }
}

use math::linalg::Matrix;
```

### –ú–æ–¥—É–ª–∏ –Ω–∞ –æ—Å–Ω–æ–≤–µ —Ñ–∞–π–ª–æ–≤ {#file-based-modules}

```
src/
‚îú‚îÄ‚îÄ main.rs
‚îú‚îÄ‚îÄ math.rs          // –∏–ª–∏ math/mod.rs
‚îî‚îÄ‚îÄ math/
    ‚îî‚îÄ‚îÄ linalg.rs
```

**src/main.rs:**

```rust
mod math;

use math::linalg::Matrix;

fn main() {
    let m = Matrix::new(3, 3);
}
```

**src/math.rs:**

```rust
pub mod linalg;

pub fn add(a: i32, b: i32) -> i32 {
    a + b
}
```

**src/math/linalg.rs:**

```rust
pub struct Matrix {
    data: Vec<f64>,
    rows: usize,
    cols: usize,
}

impl Matrix {
    pub fn new(rows: usize, cols: usize) -> Self {
        Matrix {
            data: vec![0.0; rows * cols],
            rows,
            cols,
        }
    }
}
```

### –†–µ–∞–ª—å–Ω—ã–π –º–∏—Ä: —Å—Ç—Ä—É–∫—Ç—É—Ä–∞ –ø—Ä–æ–µ–∫—Ç–∞ –Ω–∞—É—á–Ω—ã—Ö –≤—ã—á–∏—Å–ª–µ–Ω–∏–π {#scientific-project-structure}

–í–æ—Ç –∫–∞–∫ –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å –æ—Ä–≥–∞–Ω–∏–∑–æ–≤–∞–Ω–∞ –±–∏–±–ª–∏–æ—Ç–µ–∫–∞ –∞–Ω–∞–ª–∏–∑–∞ –º–µ—Ç–æ–¥–æ–º –∫–æ–Ω–µ—á–Ω—ã—Ö —ç–ª–µ–º–µ–Ω—Ç–æ–≤:

```
rust_fem/
‚îú‚îÄ‚îÄ Cargo.toml                  # –ì–ª–∞–≤–Ω–∞—è –±–∏–±–ª–∏–æ—Ç–µ–∫–∞
‚îú‚îÄ‚îÄ Cargo.lock
‚îú‚îÄ‚îÄ README.md
‚îú‚îÄ‚îÄ benches/
‚îÇ   ‚îú‚îÄ‚îÄ stiffness_assembly.rs   # –ë–µ–Ω—á–º–∞—Ä–∫–∏ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏
‚îÇ   ‚îî‚îÄ‚îÄ linear_solver.rs
‚îú‚îÄ‚îÄ examples/
‚îÇ   ‚îú‚îÄ‚îÄ cantilever_beam.rs     # –ü—Ä–∏–º–µ—Ä—ã –∑–∞–¥–∞—á
‚îÇ   ‚îú‚îÄ‚îÄ plate_bending.rs
‚îÇ   ‚îî‚îÄ‚îÄ tutorial_01.rs
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ lib.rs                # –¢–æ—á–∫–∞ –≤—Ö–æ–¥–∞ –ø—É–±–ª–∏—á–Ω–æ–≥–æ API
‚îÇ   ‚îú‚îÄ‚îÄ elements/             # –†–µ–∞–ª–∏–∑–∞—Ü–∏–∏ –∫–æ–Ω–µ—á–Ω—ã—Ö —ç–ª–µ–º–µ–Ω—Ç–æ–≤
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ mod.rs
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ bar.rs           # 1D —Å—Ç–µ—Ä–∂–Ω–µ–≤–æ–π —ç–ª–µ–º–µ–Ω—Ç
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ beam.rs          # –ë–∞–ª–∫–∞ –≠–π–ª–µ—Ä–∞-–ë–µ—Ä–Ω—É–ª–ª–∏
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ triangle.rs       # 2D —Ç—Ä–µ—É–≥–æ–ª—å–Ω–∏–∫ (–ø–ª–æ—Å–∫–æ–µ –Ω–∞–ø—Ä—è–∂–µ–Ω–∏–µ/–¥–µ—Ñ–æ—Ä–º–∞—Ü–∏—è)
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ tetrahedron.rs   # 3D —Ç–µ—Ç—Ä–∞—ç–¥—Ä
‚îÇ   ‚îú‚îÄ‚îÄ materials/            # –û–ø—Ä–µ–¥–µ–ª—è—é—â–∏–µ –º–æ–¥–µ–ª–∏
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ mod.rs
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ isotropic.rs
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ orthotropic.rs
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ hyperelastic.rs
‚îÇ   ‚îú‚îÄ‚îÄ solvers/              # –†–µ—à–∞—Ç–µ–ª–∏ –ª–∏–Ω–µ–π–Ω–æ–π –∞–ª–≥–µ–±—Ä—ã
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ mod.rs
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ direct.rs        # LU, QR, –•–æ–ª–µ—Ü–∫–∏–π
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ iterative.rs      # CG, GMRES
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ sparse.rs        # –§–æ—Ä–º–∞—Ç—ã CSR, CSC
‚îÇ   ‚îú‚îÄ‚îÄ mesh/                # –°—Ç—Ä—É–∫—Ç—É—Ä—ã –¥–∞–Ω–Ω—ã—Ö —Å–µ—Ç–∫–∏
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ mod.rs
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ topology.rs
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ connectivity.rs
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ io.rs           # –í–≤–æ–¥-–≤—ã–≤–æ–¥ —Å–µ—Ç–∫–∏ (VTK, OBJ –∏ —Ç.–¥.)
‚îÇ   ‚îî‚îÄ‚îÄ utils/               # –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏
‚îÇ       ‚îú‚îÄ‚îÄ mod.rs
‚îÇ       ‚îú‚îÄ‚îÄ math.rs
‚îÇ       ‚îî‚îÄ‚îÄ integration.rs    # –ö–≤–∞–¥—Ä–∞—Ç—É—Ä–∞ –ì–∞—É—Å—Å–∞
‚îú‚îÄ‚îÄ tests/
‚îÇ   ‚îú‚îÄ‚îÄ integration_tests.rs  # –ü–æ–ª–Ω—ã–µ —Ç–µ—Å—Ç—ã —Ä–∞–±–æ—á–µ–≥–æ –ø—Ä–æ—Ü–µ—Å—Å–∞
‚îÇ   ‚îî‚îÄ‚îÄ property_tests.rs    # –¢–µ—Å—Ç—ã –Ω–∞ –æ—Å–Ω–æ–≤–µ —Å–≤–æ–π—Å—Ç–≤
‚îî‚îÄ‚îÄ docs/
    ‚îî‚îÄ‚îÄ tutorials/
        ‚îú‚îÄ‚îÄ 01_getting_started.md
        ‚îú‚îÄ‚îÄ 02_linear_elasticity.md
        ‚îî‚îÄ‚îÄ 03_nonlinear_materials.md
```

**src/lib.rs** ‚Äî –ü—É–±–ª–∏—á–Ω—ã–π API:

```rust
// –†–µ—ç–∫—Å–ø–æ—Ä—Ç –Ω–∞–∏–±–æ–ª–µ–µ —á–∞—Å—Ç—ã—Ö —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –Ω–∞ –≤–µ—Ä—Ö–Ω–µ–º —É—Ä–æ–≤–Ω–µ
pub use elements::{BarElement, TriangleElement};
pub use materials::{IsotropicMaterial, Material};
pub use mesh::{Mesh, Node, Element};
pub use solvers::{LinearSolver, SparseSolver};

// –û–±—ä—è–≤–ª–µ–Ω–∏–µ –ø–æ–¥–º–æ–¥—É–ª–µ–π
pub mod elements;
pub mod materials;
pub mod solvers;
pub mod mesh;
pub mod utils;

// –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –≤–µ—Ä—Å–∏–∏
pub const VERSION: &str = env!("CARGO_PKG_VERSION");

// –ú–æ–¥—É–ª—å prelude –¥–ª—è —É–¥–æ–±—Å—Ç–≤–∞
pub mod prelude {
    pub use crate::elements::*;
    pub use crate::materials::*;
    pub use crate::mesh::*;
}
```

**–ö–æ–¥ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è —Å—Ç–∞–Ω–æ–≤–∏—Ç—Å—è —á–∏—Å—Ç—ã–º:**

```rust
// –ë–µ–∑ prelude
use rust_fem::elements::TriangleElement;
use rust_fem::materials::IsotropicMaterial;
use rust_fem::mesh::Mesh;
use rust_fem::solvers::LinearSolver;

// –° prelude
use rust_fem::prelude::*;

fn main() {
    let material = IsotropicMaterial::steel();
    let mut mesh = Mesh::new();
    mesh.add_triangle(/* ... */);
    let solver = LinearSolver::new();
    let solution = solver.solve(&mesh, &material);
}
```

### –ü—Ä–∞–≤–∏–ª–∞ –≤–∏–¥–∏–º–æ—Å—Ç–∏ {#visibility-rules}

```rust
pub mod outer {
    pub struct Public;            // –í–∏–¥–∏–º–∞ –≤–µ–∑–¥–µ
    struct Private;               // –¢–æ–ª—å–∫–æ –≤ —ç—Ç–æ–º –º–æ–¥—É–ª–µ
    pub(crate) struct CrateOnly;  // –¢–æ–ª—å–∫–æ –≤ —ç—Ç–æ–º –∫—Ä–µ–π—Ç–µ
    pub(super) struct ParentOnly; // –¢–æ–ª—å–∫–æ –≤ —Ä–æ–¥–∏—Ç–µ–ª—å—Å–∫–æ–º –º–æ–¥—É–ª–µ

    pub mod inner {
        pub(in crate::outer) struct OuterOnly; // –¢–æ–ª—å–∫–æ –≤ outer
    }
}
```

### –û–≥—Ä–∞–Ω–∏—á–µ–Ω–Ω–∞—è –≤–∏–¥–∏–º–æ—Å—Ç—å: —Å–∫—Ä—ã—Ç—å –≤–Ω—É—Ç—Ä–µ–Ω–Ω–æ—Å—Ç–∏ {#restricted-visibility}

–í—ã –Ω–µ —Ö–æ—Ç–∏—Ç–µ, —á—Ç–æ–±—ã –∫–∞–∂–¥–∞—è –≤–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –¥–µ—Ç–∞–ª—å –±—ã–ª–∞ –æ—Ç–∫—Ä—ã—Ç–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º. Rust –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª—è–µ—Ç –¥–µ—Ç–∞–ª—å–Ω—ã–π –∫–æ–Ω—Ç—Ä–æ–ª—å:

```rust
// –ë–∞–∑–æ–≤—ã–π –º–æ–¥—É–ª—å ‚Äî –≤–Ω—É—Ç—Ä–µ–Ω–Ω–æ—Å—Ç–∏ –±–∏–±–ª–∏–æ—Ç–µ–∫–∏
pub mod core {
    // –ü—É–±–ª–∏—á–Ω—ã–π API ‚Äî –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –≤–Ω–µ—à–Ω–∏–º–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º–∏
    pub struct Solver {
        // –í–Ω—É—Ç—Ä–µ–Ω–Ω–æ—Å—Ç–∏: —Å–∫—Ä—ã—Ç—ã –æ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π
        solver_type: SolverType,
        tolerance: f64,
    }

    // SolverType –≤–∏–¥–∏–º —Ç–æ–ª—å–∫–æ –≤ —ç—Ç–æ–º –∫—Ä–µ–π—Ç–µ
    pub(crate) enum SolverType {
        Direct { method: DirectMethod },
        Iterative { method: IterativeMethod },
    }

    pub enum DirectMethod {
        LU,
        QR,
        Cholesky,
    }

    pub enum IterativeMethod {
        CG,
        GMRES,
        BICGSTAB,
    }

    // –ü—Ä–∏–≤–∞—Ç–Ω—ã–π —Ö–µ–ª–ø–µ—Ä ‚Äî —Ç–æ–ª—å–∫–æ –≤ —ç—Ç–æ–º –º–æ–¥—É–ª–µ
    fn check_convergence(residual: f64, tol: f64) -> bool {
        residual < tol
    }

    // –¢–æ–ª—å–∫–æ –≤–Ω—É—Ç—Ä–µ–Ω–Ω–æ—Å—Ç–∏ —Ä–µ—à–∞—Ç–µ–ª—è –º–æ–≥—É—Ç –≤—ã–∑—ã–≤–∞—Ç—å —ç—Ç–æ
    pub(super) fn choose_preconditioner(matrix_type: &MatrixType) -> Preconditioner {
        // ...
    }
}

// –ú–æ–¥—É–ª—å –±–æ–ª–µ–µ –≤—ã—Å–æ–∫–æ–≥–æ —É—Ä–æ–≤–Ω—è
pub mod solvers {
    use crate::core::{Solver, SolverType};

    pub fn create_default() -> Solver {
        Solver {
            // –ú–æ–∂–Ω–æ –ø–æ–ª—É—á–∏—Ç—å –¥–æ—Å—Ç—É–ø –∫ pub(crate), –ø–æ—Ç–æ–º—É —á—Ç–æ —Ç–æ—Ç –∂–µ –∫—Ä–µ–π—Ç
            solver_type: SolverType::Iterative {
                method: DirectMethod::LU  // –û—à–∏–±–∫–∞! DirectMethod –ø—Ä–∏–≤–∞—Ç–Ω—ã–π
            },
            tolerance: 1e-8,
        }
    }

    pub struct LinearSolver {
        solver: Solver,  // –ö–æ–º–ø–æ–∑–∏—Ü–∏—è
    }
}
```

**–¢–∞–±–ª–∏—Ü–∞ –≤–∏–¥–∏–º–æ—Å—Ç–∏:**

| –í–∏–¥–∏–º–æ—Å—Ç—å                  | –ì–¥–µ –≤–∏–¥–∏–º–æ?              | –ü—Ä–∏–º–µ—Ä –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è      |
| -------------------------- | ------------------------ | ------------------------- |
| `pub`                      | –í–µ–∑–¥–µ                    | API –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π     |
| `pub(crate)`               | –¢–æ–ª—å–∫–æ —Ç–æ—Ç –∂–µ –∫—Ä–µ–π—Ç      | –í–Ω—É—Ç—Ä–µ–Ω–Ω–∏–µ –∞–±—Å—Ç—Ä–∞–∫—Ü–∏–∏     |
| `pub(super)`               | –¢–æ–ª—å–∫–æ —Ä–æ–¥–∏—Ç–µ–ª—å—Å–∫–∏–π –º–æ–¥—É–ª—å | –•–µ–ª–ø–µ—Ä—ã –º–æ–¥—É–ª—è          |
| `pub(in path::to::module)` | –¢–æ–ª—å–∫–æ –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã–π –º–æ–¥—É–ª—å | –ì–ª—É–±–æ–∫–∏–µ –≤–Ω—É—Ç—Ä–µ–Ω–Ω–∏–µ API   |
| (–ø—Ä–∏–≤–∞—Ç–Ω—ã–π)                | –¢–æ–ª—å–∫–æ —Ç–µ–∫—É—â–∏–π –º–æ–¥—É–ª—å    | –î–µ—Ç–∞–ª–∏ —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏         |

**–ü–∞—Ç—Ç–µ—Ä–Ω –ª—É—á—à–∏—Ö –ø—Ä–∞–∫—Ç–∏–∫ –¥–ª—è –Ω–∞—É—á–Ω—ã—Ö –±–∏–±–ª–∏–æ—Ç–µ–∫:**

```rust
// –°–ª–æ–π 1: API –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π (–ø—Ä–æ—Å—Ç–æ–π, —Ö–æ—Ä–æ—à–æ –¥–æ–∫—É–º–µ–Ω—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã–π)
pub mod api {
    pub fn solve_fem(problem: &Problem) -> Solution {
        let builder = InternalBuilder::from(problem);
        let workspace = builder.build_workspace();
        internal::solve(&workspace)
    }
}

// –°–ª–æ–π 2: –í–Ω—É—Ç—Ä–µ–Ω–Ω–∏–µ –∞–±—Å—Ç—Ä–∞–∫—Ü–∏–∏ (—Å—Ç–∞–±–∏–ª—å–Ω—ã–µ, –¥–æ–∫—É–º–µ–Ω—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ, –Ω–æ –ø—Ä–∏–≤–∞—Ç–Ω—ã–µ)
pub(crate) mod internal {
    pub fn solve(workspace: &Workspace) -> Solution {
        // –°–ª–æ–∂–Ω–∞—è —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è
    }

    pub struct Workspace { /* ... */ }
}

// –°–ª–æ–π 3: –î–µ—Ç–∞–ª–∏ —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏ (–º–æ–≥—É—Ç —Å–≤–æ–±–æ–¥–Ω–æ –º–µ–Ω—è—Ç—å—Å—è)
mod low_level {
    fn assembly_loop(/* ... */) { /* ... */ }

    unsafe fn raw_blas_call(/* ... */) { /* ... */ }
}
```

–≠—Ç–æ –ø–æ–∑–≤–æ–ª—è–µ—Ç –≤–∞–º **—Ä–µ—Ñ–∞–∫—Ç–æ—Ä–∏—Ç—å –≤–Ω—É—Ç—Ä–µ–Ω–Ω–æ—Å—Ç–∏** –±–µ–∑ –Ω–∞—Ä—É—à–µ–Ω–∏—è –∫–æ–¥–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π!

### `use` vs –ø–æ–ª–Ω—ã–µ –ø—É—Ç–∏: –∫–æ–≥–¥–∞ —á—Ç–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å {#use-vs-full-paths}

–û–±–∞ –≤–∞—Ä–∏–∞–Ω—Ç–∞ —Ä–∞–±–æ—Ç–∞—é—Ç, –Ω–æ –∏–º–µ—é—Ç —Ä–∞–∑–Ω—ã–µ –∫–æ–º–ø—Ä–æ–º–∏—Å—Å—ã:

```rust
// –í–∞—Ä–∏–∞–Ω—Ç 1: –ü–æ–ª–Ω—ã–µ –ø—É—Ç–∏ (–º–Ω–æ–≥–æ—Å–ª–æ–≤–Ω–æ, –Ω–æ —è–≤–Ω–æ)
fn compute(matrix: &math::linalg::Matrix, vector: &math::linalg::Vector) -> math::linalg::Vector {
    math::linalg::solve(matrix, vector)
}

// –í–∞—Ä–∏–∞–Ω—Ç 2: –û–ø–µ—Ä–∞—Ç–æ—Ä—ã use (—á–∏—â–µ, –Ω–æ –Ω—É–∂–Ω–æ –æ—Ç—Å–ª–µ–∂–∏–≤–∞—Ç—å –∏–º–ø–æ—Ä—Ç—ã)
use math::linalg::{Matrix, Vector, solve};

fn compute(matrix: &Matrix, vector: &Vector) -> Vector {
    solve(matrix, vector)
}
```

**–†—É–∫–æ–≤–æ–¥—Å—Ç–≤–æ –ø–æ –≤—ã–±–æ—Ä—É:**

| –°–∏—Ç—É–∞—Ü–∏—è          | –†–µ–∫–æ–º–µ–Ω–¥—É–µ—Ç—Å—è           | –ü–æ—á–µ–º—É                    |
| ----------------- | ----------------------- | ------------------------- |
| **–û–¥–Ω–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ** | –ü–æ–ª–Ω—ã–π –ø—É—Ç—å           | –ò–∑–±–µ–≥–∞–µ—Ç –∑–∞—Å–æ—Ä–µ–Ω–∏—è –∏–º–ø–æ—Ä—Ç–æ–≤ |
| **–ß–∞—Å—Ç–æ–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ** | `use`               | –£–º–µ–Ω—å—à–∞–µ—Ç –ø–æ–≤—Ç–æ—Ä–µ–Ω–∏–µ      |
| **API –º–æ–¥—É–ª—è**    | –†–µ—ç–∫—Å–ø–æ—Ä—Ç —Å `pub use`   | –ß–∏—â–µ –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è     |
| **–ö–æ–Ω—Ñ–ª–∏–∫—Ç—ã –∏–º—ë–Ω** | –ò–º–ø–æ—Ä—Ç —Å –ø—Å–µ–≤–¥–æ–Ω–∏–º–æ–º   | `use foo::Bar as FooBar`  |

**–õ—É—á—à–∞—è –ø—Ä–∞–∫—Ç–∏–∫–∞: –ú–æ–¥—É–ª–∏ Prelude**

–°–æ–∑–¥–∞–π—Ç–µ –º–æ–¥—É–ª—å `prelude` –¥–ª—è —á–∞—Å—Ç–æ –∏–º–ø–æ—Ä—Ç–∏—Ä—É–µ–º—ã—Ö —ç–ª–µ–º–µ–Ω—Ç–æ–≤:

```rust
// src/prelude.rs
pub use crate::types::{Vector, Matrix, Tensor};
pub use crate::elements::{Element, Material};
pub use crate::solvers::{Solver, IterativeSolver};
pub use num_traits::{Float, One, Zero};

// src/lib.rs
pub mod prelude;

// –ö–æ–¥ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
use rust_fem::prelude::*;  // –í—Å—ë, —á—Ç–æ –∏–º –Ω—É–∂–Ω–æ!
```

**–ê–Ω—Ç–∏-–ø–∞—Ç—Ç–µ—Ä–Ω: –ß—Ä–µ–∑–º–µ—Ä–Ω–æ–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ `use`**

```rust
// –ü–ª–æ—Ö–æ: –ò–º–ø–æ—Ä—Ç–∏—Ä—É–µ—Ç –≤—Å—ë, –Ω–µ—è—Å–Ω–æ, –æ—Ç–∫—É–¥–∞ —Ç–∏–ø—ã
use math::*;
use physics::*;
use utils::*;

fn compute(x: f64) -> f64 {
    // –û—Ç–∫—É–¥–∞ Vector?
    let v = Vector::new();  // –ù–µ–æ–¥–Ω–æ–∑–Ω–∞—á–Ω–æ!
}

// –•–æ—Ä–æ—à–æ: –Ø–≤–Ω—ã–µ –∏–º–ø–æ—Ä—Ç—ã
use math::Vector;
use physics::compute_forces;

fn compute(x: f64) -> f64 {
    let v = Vector::new();  // –ü–æ–Ω—è—Ç–Ω–æ!
}
```

### –†–∞–±–æ—á–∏–µ –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–∞ –¥–ª—è –º–Ω–æ–≥–æ–∫—Ä–µ–π—Ç–æ–≤—ã—Ö –ø—Ä–æ–µ–∫—Ç–æ–≤ {#workspaces}

–ü—Ä–æ–µ–∫—Ç—ã –Ω–∞—É—á–Ω—ã—Ö –≤—ã—á–∏—Å–ª–µ–Ω–∏–π —á–∞—Å—Ç–æ —Ä–∞–∑–¥–µ–ª—è—é—Ç—Å—è –Ω–∞ **–æ—Ç–¥–µ–ª—å–Ω—ã–µ –∫—Ä–µ–π—Ç—ã** –¥–ª—è —Ä–∞–∑–Ω—ã—Ö –∑–∞–¥–∞—á:

```
my_project/
‚îú‚îÄ‚îÄ Cargo.toml          # –ú–∞–Ω–∏—Ñ–µ—Å—Ç —Ä–∞–±–æ—á–µ–≥–æ –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–∞
‚îú‚îÄ‚îÄ core/
‚îÇ   ‚îú‚îÄ‚îÄ Cargo.toml      # –ë–∏–±–ª–∏–æ—Ç–µ—á–Ω—ã–π –∫—Ä–µ–π—Ç
‚îÇ   ‚îî‚îÄ‚îÄ src/lib.rs
‚îú‚îÄ‚îÄ cli/
‚îÇ   ‚îú‚îÄ‚îÄ Cargo.toml      # –ë–∏–Ω–∞—Ä–Ω—ã–π –∫—Ä–µ–π—Ç
‚îÇ   ‚îî‚îÄ‚îÄ src/main.rs
‚îî‚îÄ‚îÄ tests/
    ‚îú‚îÄ‚îÄ Cargo.toml      # –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏–æ–Ω–Ω—ã–µ —Ç–µ—Å—Ç—ã
    ‚îî‚îÄ‚îÄ src/lib.rs
```

**Workspace Cargo.toml:**

```toml
[workspace]
members = ["core", "cli", "tests"]

[workspace.dependencies]
nalgebra = "0.33"
```

**cli/Cargo.toml:**

```toml
[package]
name = "my_project_cli"
version = "0.1.0"
edition = "2021"

[dependencies]
my_project_core = { path = "../core" }
nalgebra = { workspace = true }
```

**–†–µ–∞–ª—å–Ω–æ–µ —Ä–∞–±–æ—á–µ–µ –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–æ —Å–∏–º—É–ª—è—Ü–∏–∏:**

```
simulation_workspace/
‚îú‚îÄ‚îÄ Cargo.toml                    # –ú–∞–Ω–∏—Ñ–µ—Å—Ç —Ä–∞–±–æ—á–µ–≥–æ –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–∞
‚îú‚îÄ‚îÄ core/                        # –ß–∏—Å–ª–µ–Ω–Ω—ã–µ –∞–ª–≥–æ—Ä–∏—Ç–º—ã
‚îÇ   ‚îú‚îÄ‚îÄ Cargo.toml
‚îÇ   ‚îî‚îÄ‚îÄ src/
‚îÇ       ‚îú‚îÄ‚îÄ lib.rs
‚îÇ       ‚îú‚îÄ‚îÄ linear_algebra.rs
‚îÇ       ‚îú‚îÄ‚îÄ finite_elements.rs
‚îÇ       ‚îî‚îÄ‚îÄ solvers.rs
‚îú‚îÄ‚îÄ mesh_io/                     # –§–æ—Ä–º–∞—Ç—ã –≤–≤–æ–¥–∞-–≤—ã–≤–æ–¥–∞ —Å–µ—Ç–∫–∏
‚îÇ   ‚îú‚îÄ‚îÄ Cargo.toml
‚îÇ   ‚îî‚îÄ‚îÄ src/
‚îÇ       ‚îú‚îÄ‚îÄ lib.rs
‚îÇ       ‚îú‚îÄ‚îÄ vtk_format.rs
‚îÇ       ‚îú‚îÄ‚îÄ obj_format.rs
‚îÇ       ‚îî‚îÄ‚îÄ abaqus_format.rs
‚îú‚îÄ‚îÄ materials/                   # –ë–∏–±–ª–∏–æ—Ç–µ–∫–∞ –º–æ–¥–µ–ª–µ–π –º–∞—Ç–µ—Ä–∏–∞–ª–æ–≤
‚îÇ   ‚îú‚îÄ‚îÄ Cargo.toml
‚îÇ   ‚îî‚îÄ‚îÄ src/
‚îÇ       ‚îú‚îÄ‚îÄ lib.rs
‚îÇ       ‚îú‚îÄ‚îÄ isotropic.rs
‚îÇ       ‚îú‚îÄ‚îÄ orthotropic.rs
‚îÇ       ‚îî‚îÄ‚îÄ hyperelastic.rs
‚îú‚îÄ‚îÄ visualization/              # –í–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è (OpenGL, VTK)
‚îÇ   ‚îú‚îÄ‚îÄ Cargo.toml
‚îÇ   ‚îî‚îÄ‚îÄ src/
‚îÇ       ‚îú‚îÄ‚îÄ lib.rs
‚îÇ       ‚îú‚îÄ‚îÄ renderer.rs
‚îÇ       ‚îî‚îÄ‚îÄ plots.rs
‚îú‚îÄ‚îÄ solver/                     # –ì–ª–∞–≤–Ω–æ–µ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ —Ä–µ—à–∞—Ç–µ–ª—è
‚îÇ   ‚îú‚îÄ‚îÄ Cargo.toml
‚îÇ   ‚îî‚îÄ‚îÄ src/main.rs
‚îî‚îÄ‚îÄ python_bindings/            # –ò–Ω—Ç–µ—Ä—Ñ–µ–π—Å Python
    ‚îú‚îÄ‚îÄ Cargo.toml
    ‚îî‚îÄ‚îÄ src/lib.rs
```

**–ö–æ—Ä–Ω–µ–≤–æ–π Cargo.toml (—Ä–∞–±–æ—á–µ–µ –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–æ):**

```toml
[workspace]
members = [
    "core",
    "mesh_io",
    "materials",
    "visualization",
    "solver",
    "python_bindings",
]
resolver = "2"

[workspace.package]
version = "0.1.0"
edition = "2021"
authors = ["Your Name <you@example.com>"]
license = "MIT OR Apache-2.0"

[workspace.dependencies]
# –í—Å–µ –∫—Ä–µ–π—Ç—ã —Ä–∞–∑–¥–µ–ª—è—é—Ç —ç—Ç–∏ –≤–µ—Ä—Å–∏–∏
nalgebra = "0.33"
num-traits = "0.2"
thiserror = "1.0"
serde = { version = "1.0", features = ["derive"] }
pyo3 = "0.20"  # –î–ª—è –ø—Ä–∏–≤—è–∑–æ–∫ Python

# –í–Ω—É—Ç—Ä–µ–Ω–Ω–∏–µ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ —Ä–∞–±–æ—á–µ–≥–æ –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–∞
rust_fem_core = { path = "core" }
rust_fem_mesh = { path = "mesh_io" }
rust_fem_materials = { path = "materials" }
rust_fem_viz = { path = "visualization" }
```

**–ü—Ä–µ–∏–º—É—â–µ—Å—Ç–≤–∞ —Ä–∞–±–æ—á–∏—Ö –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤:**

**–û–±—â–∏–µ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏**: –û–±–Ω–æ–≤–ª—è–π—Ç–µ –æ–¥–∏–Ω —Ä–∞–∑, –≤—Å–µ –∫—Ä–µ–π—Ç—ã –ø–æ–ª—É—á–∞—é—Ç
**–£–Ω–∏—Ñ–∏—Ü–∏—Ä–æ–≤–∞–Ω–Ω–∞—è –∫–æ–º–ø–∏–ª—è—Ü–∏—è**: `cargo build -p all` —Å–æ–±–∏—Ä–∞–µ—Ç –≤—Å—ë
**–û–±—â–∞—è –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—è target**: –ë–æ–ª–µ–µ –±—ã—Å—Ç—Ä—ã–µ –ø–µ—Ä–µ—Å–±–æ—Ä–∫–∏
**–°–æ–≥–ª–∞—Å–æ–≤–∞–Ω–Ω–æ–µ —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ**: `cargo test --workspace` –∑–∞–ø—É—Å–∫–∞–µ—Ç –≤—Å–µ —Ç–µ—Å—Ç—ã

**–ö–æ–º–∞–Ω–¥—ã —Ä–∞–±–æ—á–µ–≥–æ –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–∞:**

```bash
# –°–æ–±—Ä–∞—Ç—å –≤—Å–µ –∫—Ä–µ–π—Ç—ã
cargo build --workspace

# –¢–µ—Å—Ç–∏—Ä–æ–≤–∞—Ç—å –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã–π –∫—Ä–µ–π—Ç
cargo test -p rust_fem_core

# –ó–∞–ø—É—Å—Ç–∏—Ç—å –±–∏–Ω–∞—Ä–Ω–∏–∫ –≤ –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–º –∫—Ä–µ–π—Ç–µ
cargo run -p rust_fem_solver -- --mesh problem.vtk

# –î–æ–±–∞–≤–∏—Ç—å –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç—å –≤–æ –≤—Å–µ –∫—Ä–µ–π—Ç—ã
cargo add serde --workspace

# –û—á–∏—Å—Ç–∏—Ç—å –≤—Å–µ —Ç–∞—Ä–≥–µ—Ç—ã
cargo clean --workspace
```

---

## 4.5 –ü–∞—Ç—Ç–µ—Ä–Ω—ã –∏—Ç–µ—Ä–∞—Ç–æ—Ä–æ–≤ –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ –¥–∞–Ω–Ω—ã—Ö {#iterator-patterns}

–ò—Ç–µ—Ä–∞—Ç–æ—Ä—ã ‚Äî —Å–µ–∫—Ä–µ—Ç–Ω–æ–µ –æ—Ä—É–∂–∏–µ Rust –¥–ª—è —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ–π –æ–±—Ä–∞–±–æ—Ç–∫–∏ –Ω–∞—É—á–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö. –û–Ω–∏ —è–≤–ª—è—é—Ç—Å—è **–∞–±—Å—Ç—Ä–∞–∫—Ü–∏—è–º–∏ —Å –Ω—É–ª–µ–≤–æ–π —Å—Ç–æ–∏–º–æ—Å—Ç—å—é** ‚Äî –∫–æ–º–ø–∏–ª—è—Ç–æ—Ä –æ–ø—Ç–∏–º–∏–∑–∏—Ä—É–µ—Ç –∏—Ö –¥–æ —Å–∫–æ—Ä–æ—Å—Ç–∏ —Ä—É–∫–æ–ø–∏—Å–Ω—ã—Ö —Ü–∏–∫–ª–æ–≤.

### iter(), iter_mut(), into_iter() ‚Äî –∫–∞–∫–æ–π –≤—ã–±—Ä–∞—Ç—å? {#iter-methods}

–≠—Ç–æ —Ç–æ—á–∫–∞ #1 –ø—É—Ç–∞–Ω–∏—Ü—ã –¥–ª—è –Ω–æ–≤—ã—Ö —Ä–∞—Å—Ç–∞—Ü–µ–µ–≤:

**–°–≤—è–∑—å —Å –≤–ª–∞–¥–µ–Ω–∏–µ–º:** –ï—Å–ª–∏ –≤—ã –ø–æ–º–Ω–∏—Ç–µ –∏–∑ [–õ–µ–∫—Ü–∏–∏ 1](./lecture-01.md), –≤ Rust –µ—Å—Ç—å —Ç—Ä–∏ –∫–ª—é—á–µ–≤—ã—Ö –ø—Ä–∞–≤–∏–ª–∞ –∑–∞–∏–º—Å—Ç–≤–æ–≤–∞–Ω–∏—è:

1. –ú–Ω–æ–≥–æ –Ω–µ–∏–∑–º–µ–Ω—è–µ–º—ã—Ö —Å—Å—ã–ª–æ–∫ (`&T`) –ò–õ–ò –æ–¥–Ω–∞ –∏–∑–º–µ–Ω—è–µ–º–∞—è —Å—Å—ã–ª–∫–∞ (`&mut T`)
2. –ù–∏–∫–æ–≥–¥–∞ –æ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω–æ
3. Borrow checker –ø—Ä–∏–º–µ–Ω—è–µ—Ç –∏—Ö –Ω–∞ —ç—Ç–∞–ø–µ –∫–æ–º–ø–∏–ª—è—Ü–∏–∏

–≠—Ç–∏ —Ç—Ä–∏ –º–µ—Ç–æ–¥–∞ –∏—Ç–µ—Ä–∞—Ç–æ—Ä–æ–≤ ‚Äî –ø—Ä–æ—Å—Ç–æ —É–¥–æ–±–Ω—ã–π —Å–ø–æ—Å–æ–± –ø—Ä–∏–º–µ–Ω–∏—Ç—å —ç—Ç–∏ –ø—Ä–∞–≤–∏–ª–∞ –∫ –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç—è–º. –î–∞–≤–∞–π—Ç–µ –ø–æ—Å–º–æ—Ç—Ä–∏–º –∫–∞–∫:

```rust
let data = vec![1.0, 2.0, 3.0, 4.0, 5.0];

// 1. iter(): –ó–∞–∏–º—Å—Ç–≤–æ–≤–∞–Ω–∏—è —Ç–æ–ª—å–∫–æ –¥–ª—è —á—Ç–µ–Ω–∏—è
for value in data.iter() {
    println!("{}", value);  // value –∏–º–µ–µ—Ç —Ç–∏–ø &f64
}
// –ü–æ—Å–ª–µ: data –≤—Å—ë –µ—â—ë –Ω–µ—Ç—Ä–æ–Ω—É—Ç–∞, –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π

// 2. iter_mut(): –ò–∑–º–µ–Ω—è–µ–º—ã–µ –∑–∞–∏–º—Å—Ç–≤–æ–≤–∞–Ω–∏—è
for value in data.iter_mut() {
    *value *= 2.0;       // value –∏–º–µ–µ—Ç —Ç–∏–ø &mut f64
}
// –ü–æ—Å–ª–µ: data = [2.0, 4.0, 6.0, 8.0, 10.0]

// 3. into_iter(): –ü–æ—Ç—Ä–µ–±–ª—è–µ—Ç –≤–ª–∞–¥–µ–Ω–∏–µ
for value in data.into_iter() {
    println!("{}", value);  // value –∏–º–µ–µ—Ç —Ç–∏–ø f64 (–≤–ª–∞–¥–µ–µ–º—ã–π)
}
// –ü–æ—Å–ª–µ: data –ò–°–ß–ï–ó–õ–ê (–ø–µ—Ä–µ–º–µ—â–µ–Ω–∞!)
```

**–°–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏–µ –ø—Ä–∞–≤–∏–ª–∞–º –≤–ª–∞–¥–µ–Ω–∏—è –∏–∑ –õ–µ–∫—Ü–∏–∏ 1:**
- `iter()` ‚Üí –ú–Ω–æ–≥–æ –Ω–µ–∏–∑–º–µ–Ω—è–µ–º—ã—Ö –∑–∞–∏–º—Å—Ç–≤–æ–≤–∞–Ω–∏–π (`&T`) –∏–∑ –õ–µ–∫—Ü–∏–∏ 1
- `iter_mut()` ‚Üí –ï–¥–∏–Ω—Å—Ç–≤–µ–Ω–Ω–æ–µ –∏–∑–º–µ–Ω—è–µ–º–æ–µ –∑–∞–∏–º—Å—Ç–≤–æ–≤–∞–Ω–∏–µ (`&mut T`) –∏–∑ –õ–µ–∫—Ü–∏–∏ 1
- `into_iter()` ‚Üí –ü–µ—Ä–µ–¥–∞—á–∞ –≤–ª–∞–¥–µ–Ω–∏—è (–ø–µ—Ä–µ–º–µ—â–µ–Ω–∏–µ) –∏–∑ –õ–µ–∫—Ü–∏–∏ 1

–¢–µ –∂–µ –ø—Ä–∞–≤–∏–ª–∞, –ø—Ä–æ—Å—Ç–æ –ø—Ä–∏–º–µ–Ω—ë–Ω–Ω—ã–µ –∫ –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç—è–º! –í–æ—Ç –ø–æ—á–µ–º—É —Å–∏—Å—Ç–µ–º–∞ –≤–ª–∞–¥–µ–Ω–∏—è Rust –æ—â—É—â–∞–µ—Ç—Å—è —Å–æ–≥–ª–∞—Å–æ–≤–∞–Ω–Ω–æ–π –ø–æ –≤—Å–µ–º—É —è–∑—ã–∫—É.

**–í–∏–∑—É–∞–ª—å–Ω—ã–π –ø–æ—Ç–æ–∫ –ø–∞–º—è—Ç–∏:**

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ iter()                                  ‚îÇ
‚îÇ                                         ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê          ‚îÇ
‚îÇ  ‚îÇ 1.0 ‚îÇ‚îÄ‚îÄ‚îÄ‚Üí‚îÇ 2.0 ‚îÇ‚îÄ‚îÄ‚îÄ‚Üí‚îÇ 3.0 ‚îÇ‚îÄ‚îÄ‚îÄ‚Üí ...  ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò          ‚îÇ
‚îÇ    ‚Üë            ‚Üë            ‚Üë          ‚îÇ
‚îÇ  &f64        &f64        &f64           ‚îÇ
‚îÇ  (—á—Ç–µ–Ω–∏–µ)    (—á—Ç–µ–Ω–∏–µ)    (—á—Ç–µ–Ω–∏–µ)       ‚îÇ
‚îÇ                                         ‚îÇ
‚îÇ  –ü–æ—Å–ª–µ: Vec –≤—Å—ë –µ—â—ë –≤–ª–∞–¥–µ–µ—Ç –¥–∞–Ω–Ω—ã–º–∏     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ into_iter()                             ‚îÇ
‚îÇ                                         ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê          ‚îÇ
‚îÇ  ‚îÇ 1.0 ‚îÇ‚îÄ‚îÄ‚îÄ‚Üí‚îÇ 2.0 ‚îÇ‚îÄ‚îÄ‚îÄ‚Üí‚îÇ 3.0 ‚îÇ‚îÄ‚îÄ‚îÄ‚Üí ...  ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò          ‚îÇ
‚îÇ    ‚Üì            ‚Üì            ‚Üì          ‚îÇ
‚îÇ  f64         f64         f64            ‚îÇ
‚îÇ  (–ø–µ—Ä–µ–º–µ—â—ë–Ω) (–ø–µ—Ä–µ–º–µ—â—ë–Ω) (–ø–µ—Ä–µ–º–µ—â—ë–Ω)    ‚îÇ
‚îÇ                                         ‚îÇ
‚îÇ  –ü–æ—Å–ª–µ: Vec –ø–æ—Ç—Ä–µ–±–ª—ë–Ω (–∏—Å—á–µ–∑!)          ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### –¶–µ–ø–æ—á–∫–∏ –º–µ—Ç–æ–¥–æ–≤ –∏—Ç–µ—Ä–∞—Ç–æ—Ä–æ–≤ {#chaining-iterator-methods}

–ù–∞—Å—Ç–æ—è—â–∞—è —Å–∏–ª–∞ –≤ —Ü–µ–ø–æ—á–∫–∞—Ö:

```rust
use std::time::Instant;

// –ó–∞–¥–∞—á–∞: –ù–∞–π—Ç–∏ —Å—Ä–µ–¥–Ω–µ–µ –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω—ã—Ö –∑–Ω–∞—á–µ–Ω–∏–π > 0.5
let data: Vec<f64> = (0..1000)
    .map(|i| i as f64 / 1000.0)
    .collect();

// –ü–æ–¥—Ö–æ–¥ 1: –†—É—á–Ω—ã–µ —Ü–∏–∫–ª—ã (–º–Ω–æ–≥–æ—Å–ª–æ–≤–Ω–æ)
fn manual_filter_mean(data: &[f64]) -> f64 {
    let mut sum = 0.0;
    let mut count = 0;
    for &value in data {
        if value > 0.5 && value > 0.0 {
            sum += value;
            count += 1;
        }
    }
    sum / count as f64
}

// –ü–æ–¥—Ö–æ–¥ 2: –¶–µ–ø–æ—á–∫–∞ –∏—Ç–µ—Ä–∞—Ç–æ—Ä–æ–≤ (–∏–¥–∏–æ–º–∞—Ç–∏—á–Ω–æ, —á–∞—Å—Ç–æ –±—ã—Å—Ç—Ä–µ–µ!)
fn iterator_filter_mean(data: &[f64]) -> f64 {
    let (sum, count) = data.iter()
        .filter(|&&x| x > 0.5 && x > 0.0)  // –¶–µ–ø–æ—á–∫–∞ —Ñ–∏–ª—å—Ç—Ä–æ–≤
        .fold((0.0, 0usize), |(s, c), &x| (s + x, c + 1));
    sum / count as f64
}

// –ë–µ–Ω—á–º–∞—Ä–∫
let start = Instant::now();
for _ in 0..10000 {
    manual_filter_mean(&data);
}
println!("–†—É—á–Ω–æ–π: {:?}", start.elapsed());

let start = Instant::now();
for _ in 0..10000 {
    iterator_filter_mean(&data);
}
println!("–ò—Ç–µ—Ä–∞—Ç–æ—Ä: {:?}", start.elapsed());

// –¢–∏–ø–∏—á–Ω—ã–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç:
// –†—É—á–Ω–æ–π: 42.1–º—Å
// –ò—Ç–µ—Ä–∞—Ç–æ—Ä: 38.7–º—Å  (–±—ã—Å—Ç—Ä–µ–µ –±–ª–∞–≥–æ–¥–∞—Ä—è –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è–º!)
```

### –†–∞—Å–ø—Ä–æ—Å—Ç—Ä–∞–Ω—ë–Ω–Ω—ã–µ –∫–æ–º–±–∏–Ω–∞—Ç–æ—Ä—ã –∏—Ç–µ—Ä–∞—Ç–æ—Ä–æ–≤ {#common-iterator-combinators}

```rust
let numbers = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

// filter: –û—Å—Ç–∞–≤–∏—Ç—å –ø–æ–¥—Ö–æ–¥—è—â–∏–µ —ç–ª–µ–º–µ–Ω—Ç—ã
let evens: Vec<_> = numbers.iter()
    .filter(|&&x| x % 2 == 0)
    .collect();
assert_eq!(evens, vec![2, 4, 6, 8, 10]);

// map: –ü—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞—Ç—å –∫–∞–∂–¥—ã–π —ç–ª–µ–º–µ–Ω—Ç
let squares: Vec<_> = numbers.iter()
    .map(|&x| x * x)
    .collect();
assert_eq!(squares, vec![1, 4, 9, 16, 25, 36, 49, 64, 81, 100]);

// filter_map: –§–∏–ª—å—Ç—Ä–∞—Ü–∏—è + –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ –∑–∞ –æ–¥–∏–Ω –ø—Ä–æ—Ö–æ–¥
let parse_positive = |s: &str| -> Option<i32> {
    let n: i32 = s.parse().ok()?;
    if n > 0 { Some(n) } else { None }
};

let inputs = vec!["10", "abc", "-5", "20"];
let valid: Vec<_> = inputs.iter()
    .filter_map(|s| parse_positive(s))
    .collect();
assert_eq!(valid, vec![10, 20]);

// flat_map: –†–∞–∑–≤–µ—Ä–Ω—É—Ç—å –≤–ª–æ–∂–µ–Ω–Ω—ã–µ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã
let lines = vec!["a,b,c", "d,e", "f"];
let chars: Vec<_> = lines.iter()
    .flat_map(|line| line.split(','))
    .collect();
assert_eq!(chars, vec!["a", "b", "c", "d", "e", "f"]);

// enumerate: –î–æ–±–∞–≤–∏—Ç—å –∏–Ω–¥–µ–∫—Å
let indexed: Vec<_> = numbers.iter()
    .enumerate()
    .filter(|(i, &x)| x % 2 == 0)
    .map(|(i, &x)| (i, x))
    .collect();
assert_eq!(indexed, vec![(1, 2), (3, 4), (5, 6), (7, 8), (9, 10)]);

// fold: –ê–∫–∫—É–º—É–ª–∏—Ä–æ–≤–∞—Ç—å –≤ –æ–¥–Ω–æ –∑–Ω–∞—á–µ–Ω–∏–µ
let factorial: u64 = (1..=6).fold(1, |acc, x| acc * x);
assert_eq!(factorial, 120);

// scan: –ö–∞–∫ fold, –Ω–æ —Å–æ—Ö—Ä–∞–Ω—è–µ—Ç –ø—Ä–æ–º–µ–∂—É—Ç–æ—á–Ω—ã–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã
let running_sum: Vec<_> = numbers.iter()
    .scan(0, |acc, &x| {
        *acc += x;
        Some(*acc)
    })
    .collect();
assert_eq!(running_sum, vec![1, 3, 6, 10, 15, 21, 28, 36, 45, 55]);
```

### –ü–æ—Ç–æ–∫–æ–≤–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞ –±–æ–ª—å—à–∏—Ö —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ —Å–∏–º—É–ª—è—Ü–∏–∏ {#streaming-large-results}

–ò—Ç–µ—Ä–∞—Ç–æ—Ä—ã **–ª–µ–Ω–∏–≤—ã–µ** ‚Äî –æ–Ω–∏ –Ω–µ –≤—ã–¥–µ–ª—è—é—Ç –ø—Ä–æ–º–µ–∂—É—Ç–æ—á–Ω—ã–µ –º–∞—Å—Å–∏–≤—ã. –≠—Ç–æ –∫—Ä–∏—Ç–∏—á–Ω–æ –¥–ª—è –±–æ–ª—å—à–∏—Ö –Ω–∞–±–æ—Ä–æ–≤ –¥–∞–Ω–Ω—ã—Ö:

```rust
use std::fs::File;
use std::io::{self, BufRead, BufReader};

/// –û–±—Ä–∞–±–æ—Ç–∫–∞ –æ–≥—Ä–æ–º–Ω–æ–≥–æ –≤—ã–≤–æ–¥–∞ —Å–∏–º—É–ª—è—Ü–∏–∏ –±–µ–∑ –∑–∞–≥—Ä—É–∑–∫–∏ –≤ –ø–∞–º—è—Ç—å
fn analyze_results_file(path: &str) -> io::Result<Analysis> {
    let file = File::open(path)?;
    let reader = BufReader::new(file);

    let (sum, count, max) = reader.lines()
        .filter_map(Result::ok)                    // –ü—Ä–æ–ø—É—Å—Ç–∏—Ç—å –ø–ª–æ—Ö–∏–µ —Å—Ç—Ä–æ–∫–∏
        .filter_map(|line| line.parse::<f64>().ok())  // –†–∞–∑–æ–±—Ä–∞—Ç—å float
        .filter(|&x| x.is_finite())                    // –ü—Ä–æ–ø—É—Å—Ç–∏—Ç—å NaN/Inf
        .fold((0.0, 0usize, f64::NEG_INFINITY), |(s, c, m), x| {
            (s + x, c + 1, m.max(x))
        });

    let mean = sum / count as f64;

    Ok(Analysis { mean, count, max })
}

// –†–∞–±–æ—Ç–∞–µ—Ç —Å —Ñ–∞–π–ª–æ–º 100–ì–ë —Å –º–∏–Ω–∏–º–∞–ª—å–Ω—ã–º –ø–æ—Ç—Ä–µ–±–ª–µ–Ω–∏–µ–º –ø–∞–º—è—Ç–∏!
// –ù–∏–∫–∞–∫–æ–≥–æ –ø—Ä–æ–º–µ–∂—É—Ç–æ—á–Ω–æ–≥–æ –≤—ã–¥–µ–ª–µ–Ω–∏—è Vec<f64>!
```

---

## 5. –û—Å–Ω–æ–≤–Ω—ã–µ –º–æ–º–µ–Ω—Ç—ã —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–æ–π –±–∏–±–ª–∏–æ—Ç–µ–∫–∏ {#standard-library-highlights}

### –ö–æ–ª–ª–µ–∫—Ü–∏–∏ {#collections}

```rust
use std::collections::{HashMap, HashSet, BTreeMap, VecDeque};

// Vec: –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–∏–π –º–∞—Å—Å–∏–≤
let mut v = vec![1, 2, 3];
v.push(4);

// HashMap: —Ö–µ—à-—Ç–∞–±–ª–∏—Ü–∞
let mut scores: HashMap<String, i32> = HashMap::new();
scores.insert("–ê–ª–∏—Å–∞".to_string(), 95);

// BTreeMap: –æ—Ç—Å–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã–π —Å–ª–æ–≤–∞—Ä—å (–ø–æ–ª–µ–∑–Ω–æ –¥–ª—è —É–ø–æ—Ä—è–¥–æ—á–µ–Ω–Ω–æ–π –∏—Ç–µ—Ä–∞—Ü–∏–∏)
let mut sorted: BTreeMap<i32, String> = BTreeMap::new();

// HashSet: —É–Ω–∏–∫–∞–ª—å–Ω—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è
let primes: HashSet<i32> = [2, 3, 5, 7, 11].into_iter().collect();
```

### –£–º–Ω—ã–µ —É–∫–∞–∑–∞—Ç–µ–ª–∏ {#smart-pointers}

```rust
use std::rc::Rc;
use std::cell::RefCell;
use std::sync::{Arc, Mutex};

// Box: –≤—ã–¥–µ–ª–µ–Ω–∏–µ –≤ –∫—É—á–µ —Å –µ–¥–∏–Ω—Å—Ç–≤–µ–Ω–Ω—ã–º –≤–ª–∞–¥–µ–ª—å—Ü–µ–º
let boxed: Box<[f64; 1000000]> = Box::new([0.0; 1000000]);

// Rc: –ø–æ–¥—Å—á—ë—Ç —Å—Å—ã–ª–æ–∫ (–æ–¥–Ω–æ–ø–æ—Ç–æ—á–Ω—ã–π)
let shared = Rc::new(vec![1, 2, 3]);
let clone = Rc::clone(&shared);

// RefCell: –≤–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –∏–∑–º–µ–Ω—è–µ–º–æ—Å—Ç—å (–ø—Ä–æ–≤–µ—Ä–∫–∞ –∑–∞–∏–º—Å—Ç–≤–æ–≤–∞–Ω–∏—è –≤–æ –≤—Ä–µ–º—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è)
let data = RefCell::new(vec![1, 2, 3]);
data.borrow_mut().push(4);

// Arc + Mutex: –ø–æ—Ç–æ–∫–æ–±–µ–∑–æ–ø–∞—Å–Ω–æ–µ —Ä–∞–∑–¥–µ–ª—è–µ–º–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ
let counter = Arc::new(Mutex::new(0));
```

---

## –†–µ–∑—é–º–µ {#summary}

| –ö–æ–Ω—Ü–µ–ø—Ü–∏—è        | C++                | Rust                     |
| ---------------- | ------------------ | ------------------------ |
| –¢–∏–ø—ã-—Å—É–º–º—ã       | `std::variant`     | `enum`                   |
| –°–æ–ø–æ—Å—Ç–∞–≤–ª–µ–Ω–∏–µ    | –û–≥—Ä–∞–Ω–∏—á–µ–Ω–Ω—ã–π `switch` | –ú–æ—â–Ω—ã–π `match`         |
| –ü–æ–ª–∏–º–æ—Ä—Ñ–∏–∑–º      | –í–∏—Ä—Ç—É–∞–ª—å–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏ | –¢–∏–ø–∞–∂–∏                  |
| –û–±–æ–±—â–µ–Ω–∏—è        | –®–∞–±–ª–æ–Ω—ã (SFINAE)   | –¢–∏–ø–∞–∂–∏ (–≥—Ä–∞–Ω–∏—Ü—ã)         |
| –û—à–∏–±–∫–∏           | –ò—Å–∫–ª—é—á–µ–Ω–∏—è         | `Result<T, E>`           |
| –ü—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–∞ –∏–º—ë–Ω | `namespace`       | `mod`                    |
| –ò—Ç–µ—Ä–∞—Ç–æ—Ä—ã        | –ò—Ç–µ—Ä–∞—Ç–æ—Ä—ã STL      | –õ–µ–Ω–∏–≤—ã–µ –∏—Ç–µ—Ä–∞—Ç–æ—Ä—ã —Å –Ω—É–ª–µ–≤–æ–π —Å—Ç–æ–∏–º–æ—Å—Ç—å—é |

---

## –¢–∏–ø–∏—á–Ω—ã–µ –ø–æ–¥–≤–æ–¥–Ω—ã–µ –∫–∞–º–Ω–∏ {#common-pitfalls}

### –ü—Ä–∞–≤–∏–ª–æ —Å–∏—Ä–æ—Ç {#orphan-rule}

–í—ã –Ω–µ –º–æ–∂–µ—Ç–µ —Ä–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å —Ç–∏–ø–∞–∂ –¥–ª—è —Ç–∏–ø–∞, –µ—Å–ª–∏ –Ω–∏ –æ–¥–∏–Ω –∏–∑ –Ω–∏—Ö –Ω–µ –æ–ø—Ä–µ–¥–µ–ª—ë–Ω –≤ –≤–∞—à–µ–º –∫—Ä–µ–π—Ç–µ:

```rust
// ‚ùå –ù–µ —Å–∫–æ–º–ø–∏–ª–∏—Ä—É–µ—Ç—Å—è!
impl std::fmt::Display for Vec<i32> {
    // –ù–∏ Display, –Ω–∏ Vec –Ω–µ –≤ –≤–∞—à–µ–º –∫—Ä–µ–π—Ç–µ
}

// ‚úÖ –ü—Ä–∞–≤–∏–ª—å–Ω–æ: –æ–ø—Ä–µ–¥–µ–ª–∏—Ç–µ —Å—Ç—Ä—É–∫—Ç—É—Ä—É-–æ–±—ë—Ä—Ç–∫—É
struct MyVec(Vec<i64>);
impl std::fmt::Display for MyVec {
    // MyVec –≤ –≤–∞—à–µ–º –∫—Ä–µ–π—Ç–µ
}
```

### –ü—É—Ç–∞–Ω–∏—Ü–∞ dyn Trait vs impl Trait {#dyn-vs-impl-trait-confusion}

```rust
// ‚úÖ –í–æ–∑–≤—Ä–∞—â–∞–µ–º—ã–π —Ç–∏–ø –∏–∑–≤–µ—Å—Ç–µ–Ω –Ω–∞ —ç—Ç–∞–ø–µ –∫–æ–º–ø–∏–ª—è—Ü–∏–∏
fn parse_file() -> impl Reader { /* ... */ }

// ‚úÖ –ù—É–∂–µ–Ω –ø–æ–ª–∏–º–æ—Ä—Ñ–∏–∑–º –≤—Ä–µ–º–µ–Ω–∏ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è
fn run_plugins(plugins: &[Box<dyn Plugin>]) { /* ... */ }

// ‚ùå –ù–µ –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ dyn, –∫–æ–≥–¥–∞ —Ç–∏–ø –∏–∑–≤–µ—Å—Ç–µ–Ω
fn compute(x: f64) -> dyn Compute { /* –ù–µ–ø—Ä–∞–≤–∏–ª—å–Ω–æ! */ }
```

### –û—à–∏–±–∫–∏ —ç–ª–∏–∑–∏–∏ –≤—Ä–µ–º—ë–Ω –∂–∏–∑–Ω–∏ {#lifetime-elision-failures}

```rust
// ‚ùå –û—à–∏–±–∫–∞: –Ω–µ–æ–¥–Ω–æ–∑–Ω–∞—á–Ω—ã–µ –≤—Ä–µ–º–µ–Ω–∞ –∂–∏–∑–Ω–∏
fn longest(x: &str, y: &str) -> &str {
    if x.len() > y.len() { x } else { y }
}

// ‚úÖ –Ø–≤–Ω—ã–µ –≤—Ä–µ–º–µ–Ω–∞ –∂–∏–∑–Ω–∏
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() { x } else { y }
}
```

### –†–∞–≤–µ–Ω—Å—Ç–≤–æ —á–∏—Å–µ–ª —Å –ø–ª–∞–≤–∞—é—â–µ–π —Ç–æ—á–∫–æ–π {#floating-point-equality}

‚ö†Ô∏è **–ù–∏–∫–æ–≥–¥–∞ –Ω–µ —Å—Ä–∞–≤–Ω–∏–≤–∞–π—Ç–µ —á–∏—Å–ª–∞ —Å –ø–ª–∞–≤–∞—é—â–µ–π —Ç–æ—á–∫–æ–π —Å `==`** –¥–ª—è –Ω–∞—É—á–Ω—ã—Ö –≤—ã—á–∏—Å–ª–µ–Ω–∏–π!

```rust
// ‚ùå –ù–ï–ü–†–ê–í–ò–õ–¨–ù–û: –ù–µ —Å—Ä–∞–±–æ—Ç–∞–µ—Ç –∏–∑-–∑–∞ –æ—à–∏–±–æ–∫ —Ç–æ—á–Ω–æ—Å—Ç–∏
fn are_equal(a: f64, b: f64) -> bool {
    a == b  // 0.1 + 0.2 ‚â† 0.3 –∏–∑-–∑–∞ –ø–ª–∞–≤–∞—é—â–µ–π —Ç–æ—á–∫–∏!
}

// ‚úÖ –ü–†–ê–í–ò–õ–¨–ù–û: –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ —Å—Ä–∞–≤–Ω–µ–Ω–∏–µ —Å epsilon
fn are_equal(a: f64, b: f64) -> bool {
    (a - b).abs() < 1e-10
}

// ‚úÖ –õ–£–ß–®–ï: –û—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω—ã–π epsilon (–ª—É—á—à–µ –¥–ª—è –±–æ–ª—å—à–∏—Ö —á–∏—Å–µ–ª)
fn are_equal_relative(a: f64, b: f64) -> bool {
    let diff = (a - b).abs();
    let max_abs = a.abs().max(b.abs());
    diff < max_abs * 1e-10
}
```

### –ö–æ–ø–∏—Ä–æ–≤–∞–Ω–∏–µ –±–æ–ª—å—à–∏—Ö –º–∞—Å—Å–∏–≤–æ–≤ {#copying-large-arrays}

‚ö†Ô∏è **–ù–µ –¥–µ—Ä–∏–≤—å—Ç–µ Clone –¥–ª—è –±–æ–ª—å—à–∏—Ö –º–∞—Å—Å–∏–≤–æ–≤ –≤ –Ω–∞—É—á–Ω–æ–º –∫–æ–¥–µ**

```rust
// ‚ùå –ù–ï–ü–†–ê–í–ò–õ–¨–ù–û: –û—á–µ–Ω—å –¥–æ—Ä–æ–≥–æ –∫–ª–æ–Ω–∏—Ä–æ–≤–∞—Ç—å
#[derive(Clone)]
struct Simulation {
    mesh: Vec<Node>,        // 1 –º–∏–ª–ª–∏–æ–Ω —É–∑–ª–æ–≤
    data: Vec<f64>,       // 10 –º–∏–ª–ª–∏–æ–Ω–æ–≤ –∑–Ω–∞—á–µ–Ω–∏–π
}

fn process(sim: &Simulation) -> Result<Output, Error> {
    let sim2 = sim.clone();  // –ö–æ–ø–∏—Ä—É–µ—Ç 11 –º–∏–ª–ª–∏–æ–Ω–æ–≤ f64!
    // –≠—Ç–æ –º–æ–∂–µ—Ç –∑–∞–Ω—è—Ç—å —Å–µ–∫—É–Ω–¥—ã!
}

// ‚úÖ –ü–†–ê–í–ò–õ–¨–ù–û: –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ —Å—Å—ã–ª–∫–∏ –∏–ª–∏ –ø–µ—Ä–µ–º–µ—â–µ–Ω–∏–µ
struct Simulation {
    mesh: Vec<Node>,
    data: Vec<f64>,
}

fn process(mut sim: Simulation) -> Result<Output, Error> {
    // –ü–µ—Ä–µ–º–µ—â–∞–µ–º –≤–ª–∞–¥–µ–Ω–∏–µ, –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏–µ –Ω–µ –Ω—É–∂–Ω–æ
    compute(&mut sim.mesh, &sim.data)
}
```

### –ù–µ–Ω—É–∂–Ω—ã–µ –∞–ª–ª–æ–∫–∞—Ü–∏–∏ {#unnecessary-allocations}

‚ö†Ô∏è **–ò–∑–±–µ–≥–∞–π—Ç–µ –∞–ª–ª–æ–∫–∞—Ü–∏–π –≤ –≥–æ—Ä—è—á–∏—Ö –ø—É—Ç—è—Ö**

```rust
// ‚ùå –ù–ï–ü–†–ê–í–ò–õ–¨–ù–û: –ê–ª–ª–æ—Ü–∏—Ä—É–µ—Ç –Ω–∞ –∫–∞–∂–¥–æ–π –∏—Ç–µ—Ä–∞—Ü–∏–∏
fn smooth(data: &[f64]) -> Vec<f64> {
    let mut result = Vec::with_capacity(data.len());
    for i in 1..data.len()-1 {
        let window = vec![data[i-1], data[i], data[i+1]];  // –ê–ª–ª–æ–∫–∞—Ü–∏—è!
        result.push(window.iter().sum::<f64>() / 3.0);
    }
    result
}

// ‚úÖ –ü–†–ê–í–ò–õ–¨–ù–û: –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∏—Ç–µ—Ä–∞—Ç–æ—Ä—ã, –Ω–æ–ª—å –∞–ª–ª–æ–∫–∞—Ü–∏–π
fn smooth(data: &[f64]) -> Vec<f64> {
    let mut result = Vec::with_capacity(data.len());
    for i in 1..data.len()-1 {
        // –ë–µ–∑ –∞–ª–ª–æ–∫–∞—Ü–∏–∏, –ø—Ä–æ—Å—Ç–æ —Å—Å—ã–ª–∫–∏ –Ω–∞ —Å—Ä–µ–∑—ã
        let sum: f64 = data[i-1..=i+1].iter().sum();
        result.push(sum / 3.0);
    }
    result
}

// ‚úÖ –ï–©–Å –õ–£–ß–®–ï: –ü–æ—Ç–æ–∫–æ–≤–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞, –∞–ª–ª–æ–∫–∞—Ü–∏—è Vec –Ω–µ –Ω—É–∂–Ω–∞
fn smooth_streaming(data: &[f64]) -> impl Iterator<Item = f64> + '_ {
    data[1..].windows(3).map(|w| w.iter().sum::<f64>() / 3.0)
}
```

### –ü–∞–Ω–∏–∫–∞ vs –æ—à–∏–±–∫–∞ –≤ –±–∏–±–ª–∏–æ—Ç–µ–∫–∞—Ö {#panic-vs-error}

‚ö†Ô∏è **–ù–∏–∫–æ–≥–¥–∞ –Ω–µ –ø–∞–Ω–∏–∫—É–π—Ç–µ –≤ –±–∏–±–ª–∏–æ—Ç–µ—á–Ω–æ–º –∫–æ–¥–µ ‚Äî –≤–æ–∑–≤—Ä–∞—â–∞–π—Ç–µ Result –≤–º–µ—Å—Ç–æ —ç—Ç–æ–≥–æ**

```rust
// ‚ùå –ù–ï–ü–†–ê–í–ò–õ–¨–ù–û: –ü–∞–Ω–∏–∫–∞ –∫—Ä–∞—à–∏—Ç –≤—Å—é –ø—Ä–æ–≥—Ä–∞–º–º—É
pub fn load_mesh(path: &str) -> Mesh {
    let data = std::fs::read_to_string(path).unwrap();  // –ü–∞–Ω–∏–∫–∞, –µ—Å–ª–∏ —Ñ–∞–π–ª –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç!
    parse_mesh(&data)  // –ü–∞–Ω–∏–∫–∞, –µ—Å–ª–∏ –Ω–µ–≤–∞–ª–∏–¥–Ω—ã–π!
}

// ‚úÖ –ü–†–ê–í–ò–õ–¨–ù–û: –í–µ—Ä–Ω—É—Ç—å –æ—à–∏–±–∫—É, –ø—É—Å—Ç—å –≤—ã–∑—ã–≤–∞—é—â–∏–π —Ä–µ—à–∏—Ç, —á—Ç–æ –¥–µ–ª–∞—Ç—å
pub fn load_mesh(path: &str) -> Result<Mesh, LoadError> {
    let data = std::fs::read_to_string(path)?;  // –ü—Ä–æ–ø–∞–≥–∏—Ä—É–µ—Ç –æ—à–∏–±–∫—É
    let mesh = parse_mesh(&data)?;  // –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç Result
    Ok(mesh)
}

// –í—ã–∑—ã–≤–∞—é—â–∏–π –º–æ–∂–µ—Ç –æ–±—Ä–∞–±–æ—Ç–∞—Ç—å —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–∏–º –æ–±—Ä–∞–∑–æ–º:
fn main() {
    match load_mesh("problem.vtk") {
        Ok(mesh) => solve(&mesh),
        Err(LoadError::FileNotFound(_)) => {
            eprintln!("–§–∞–π–ª –Ω–µ –Ω–∞–π–¥–µ–Ω, –∏—Å–ø–æ–ª—å–∑—É–µ–º —Å–µ—Ç–∫—É –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é");
            let default = create_default_mesh();
            solve(&default);
        }
        Err(e) => {
            eprintln!("–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ —Å–µ—Ç–∫–∏: {}", e);
            std::process::exit(1);
        }
    }
}
```

### –ü–æ–¥–≤–æ–¥–Ω—ã–µ –∫–∞–º–Ω–∏, —Å–ø–µ—Ü–∏—Ñ–∏—á–Ω—ã–µ –¥–ª—è –Ω–∞—É—á–Ω—ã—Ö –≤—ã—á–∏—Å–ª–µ–Ω–∏–π {#scientific-specific-pitfalls}

#### –ü–æ–¥–≤–æ–¥–Ω—ã–π –∫–∞–º–µ–Ω—å 1: –ß–∏—Å–ª–µ–Ω–Ω–∞—è —É—Å—Ç–æ–π—á–∏–≤–æ—Å—Ç—å {#numerical-stability}

```rust
// ‚ùå –ö–∞—Ç–∞—Å—Ç—Ä–æ—Ñ–∏—á–µ—Å–∫–∞—è –æ—Ç–º–µ–Ω–∞
fn quadratic_roots_bad(a: f64, b: f64, c: f64) -> Option<(f64, f64)> {
    let discriminant = b * b - 4.0 * a * c;
    if discriminant < 0.0 { return None; }

    let sqrt_d = discriminant.sqrt();
    let x1 = (-b + sqrt_d) / (2.0 * a);  // –û—Ç–º–µ–Ω—è–µ—Ç –∑–Ω–∞—á–∞—â–∏–µ —Ü–∏—Ñ—Ä—ã!
    let x2 = (-b - sqrt_d) / (2.0 * a);
    Some((x1, x2))
}

// ‚úÖ –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∞–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω—É—é —Ñ–æ—Ä–º—É–ª—É
fn quadratic_roots_good(a: f64, b: f64, c: f64) -> Option<(f64, f64)> {
    let discriminant = b * b - 4.0 * a * c;
    if discriminant < 0.0 { return None; }

    let sqrt_d = discriminant.sqrt();
    let q = -0.5 * (b + b.copysign(sqrt_d));

    let x1 = q / a;
    let x2 = (if q.abs() < 1e-10 { sqrt_d } else { c / q }) / a;
    Some((x1, x2))
}
```

#### –ü–æ–¥–≤–æ–¥–Ω—ã–π –∫–∞–º–µ–Ω—å 2: –û—à–∏–±–∫–∞ –Ω–∞–∫–æ–ø–ª–µ–Ω–∏—è {#accumulation-error}

```rust
// ‚ùå –ù–ï–ü–†–ê–í–ò–õ–¨–ù–û: –ù–∞–∫–∞–ø–ª–∏–≤–∞–µ—Ç –æ—à–∏–±–∫—É
fn sum_floats_bad(data: &[f64]) -> f64 {
    let mut total = 0.0;
    for &x in data {
        total += x;  // –ü–æ—Ç–µ—Ä—è —Ç–æ—á–Ω–æ—Å—Ç–∏ –¥–ª—è –±–æ–ª—å—à–∏—Ö –º–∞—Å—Å–∏–≤–æ–≤
    }
    total
}

// ‚úÖ –ü–†–ê–í–ò–õ–¨–ù–û: –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ —Å—É–º–º–∏—Ä–æ–≤–∞–Ω–∏–µ –ö–∞—Ö–∞–Ω–∞ –∏–ª–∏ –ø–æ–ø–∞—Ä–Ω–æ–µ —Å—É–º–º–∏—Ä–æ–≤–∞–Ω–∏–µ
fn kahan_sum(data: &[f64]) -> f64 {
    let mut sum = 0.0;
    let mut c = 0.0;  // –ë–µ–≥—É—â–∞—è –∫–æ–º–ø–µ–Ω—Å–∞—Ü–∏—è –ø–æ—Ç–µ—Ä—è–Ω–Ω—ã—Ö –º–ª–∞–¥—à–∏—Ö –±–∏—Ç–æ–≤

    for &x in data {
        let y = x - c;
        let t = sum + y;
        c = (t - sum) - y;  // –ß–ª–µ–Ω –∫–æ–º–ø–µ–Ω—Å–∞—Ü–∏–∏
        sum = t;
    }
    sum
}

fn pairwise_sum(data: &[f64]) -> f64 {
    // –ò–ª–∏ –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ –≤—Å—Ç—Ä–æ–µ–Ω–Ω–æ–µ —Å—É–º–º–∏—Ä–æ–≤–∞–Ω–∏–µ f64 (—á–∞—Å—Ç–æ –æ–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–æ)
    data.iter().sum()
}
```

---

## –°–ª–µ–¥—É—é—â–∏–µ —à–∞–≥–∏ {#next-steps}

- **–°–µ–º–∏–Ω–∞—Ä 2.1**: [–¢–∏–ø–∞–∂–∏ –∏ –æ–±–æ–±—â–µ–Ω–∏—è](../seminars/seminar-02-1.md)
- **–°–µ–º–∏–Ω–∞—Ä 2.2**: [–û–±—Ä–∞–±–æ—Ç–∫–∞ –æ—à–∏–±–æ–∫ –∏ —Å—Ç—Ä—É–∫—Ç—É—Ä–∞ –ø—Ä–æ–µ–∫—Ç–∞](../seminars/seminar-02-2.md)

## –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ–µ —á—Ç–µ–Ω–∏–µ {#additional-reading}

- [The Rust Programming Language, –≥–ª–∞–≤–∞ 10 (–û–±–æ–±—â–µ–Ω–∏—è, —Ç–∏–ø–∞–∂–∏, –≤—Ä–µ–º–µ–Ω–∞ –∂–∏–∑–Ω–∏)](https://doc.rust-lang.org/book/ch10-00-generics.html)
- [Rust by Example: –¢–∏–ø–∞–∂–∏](https://doc.rust-lang.org/rust-by-example/trait.html)
- [–†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏ –ø–æ API](https://rust-lang.github.io/api-guidelines/)
